package org.opentestsystem.ap.imrt.iss.model.reports.gap;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang3.math.NumberUtils;
import org.apache.poi.ss.usermodel.BorderStyle;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.IndexedColors;
import org.apache.poi.ss.util.CellRangeAddress;
import org.apache.poi.xssf.usermodel.DefaultIndexedColorMap;
import org.apache.poi.xssf.usermodel.XSSFCell;
import org.apache.poi.xssf.usermodel.XSSFCellStyle;
import org.apache.poi.xssf.usermodel.XSSFColor;
import org.apache.poi.xssf.usermodel.XSSFConditionalFormattingRule;
import org.apache.poi.xssf.usermodel.XSSFFont;
import org.apache.poi.xssf.usermodel.XSSFFontFormatting;
import org.apache.poi.xssf.usermodel.XSSFPatternFormatting;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFSheetConditionalFormatting;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.xssf.usermodel.extensions.XSSFCellBorder;
import org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty;
import org.opentestsystem.ap.imrt.iss.model.BooleanFlagSearchFilter;
import org.opentestsystem.ap.imrt.iss.model.ContainsSearchFilter;
import org.opentestsystem.ap.imrt.iss.model.DateRangeSearchFilter;
import org.opentestsystem.ap.imrt.iss.model.DaysBetweenSearchFilter;
import org.opentestsystem.ap.imrt.iss.model.IdMatchSearchFilter;
import org.opentestsystem.ap.imrt.iss.model.IntegerRangeSearchFilter;
import org.opentestsystem.ap.imrt.iss.model.MatchSearchFilter;
import org.opentestsystem.ap.imrt.iss.model.SearchFilter;
import org.springframework.stereotype.Component;

import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.CONTENT_CHANGED_AFTER_OPERATIONAL;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.CURRENT_UPDATE_NEED_INTERNAL_RESOLUTION;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.CURRENT_UPDATE_NEED_RESOLUTION;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.DOK;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.ENGLISH_GLOSSARY_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.HAS_UNRESOLVED_UPDATE_NEED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.ILLUSTRATED_GLOSSARY_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.ILLUSTRATED_GLOSSARY_REQUIRED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.INTENDED_GRADE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.ITEM_AUTHOR;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.ITEM_DIFFICULTY_QUINTILE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.ITEM_TYPE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.ORGANIZATION_NAME;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.ORGANIZATION_TYPE_ID;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.PRIMARY_CLAIM;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.PRIMARY_COMMON_CORE_STANDARD;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.PRIMARY_CONTENT_DOMAIN;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.PRIMARY_TARGET;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.QUATERNARY_CLAIM;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.QUATERNARY_COMMON_CORE_STANDARD;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.QUATERNARY_CONTENT_DOMAIN;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.QUATERNARY_TARGET;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.SECONDARY_CLAIM;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.SECONDARY_COMMON_CORE_STANDARD;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.SECONDARY_CONTENT_DOMAIN;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.SECONDARY_TARGET;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.SUBJECT;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.TERTIARY_CLAIM;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.TERTIARY_COMMON_CORE_STANDARD;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.TERTIARY_CONTENT_DOMAIN;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.TERTIARY_TARGET;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.TEST_CATEGORY;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.TRANSLATED_GLOSSARY_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.TRANSLATED_GLOSSARY_REQUIRED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.WORKFLOW_STATUS;
import static org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReportCalculationField.ACTUAL_DIFFICULTY_COUNT;
import static org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReportCalculationField.ACTUAL_DIFFICULTY_FIVE;
import static org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReportCalculationField.ACTUAL_DIFFICULTY_FOUR;
import static org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReportCalculationField.ACTUAL_DIFFICULTY_ONE;
import static org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReportCalculationField.ACTUAL_DIFFICULTY_THREE;
import static org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReportCalculationField.ACTUAL_DIFFICULTY_TWO;
import static org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReportCalculationField.DELTA_DIFFICULTY_COUNT;
import static org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReportCalculationField.DELTA_DIFFICULTY_FIVE;
import static org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReportCalculationField.DELTA_DIFFICULTY_FOUR;
import static org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReportCalculationField.DELTA_DIFFICULTY_ONE;
import static org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReportCalculationField.DELTA_DIFFICULTY_THREE;
import static org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReportCalculationField.DELTA_DIFFICULTY_TWO;
import static org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReportCalculationField.DESIRED_DIFFICULTY_COUNT;
import static org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReportCalculationField.DESIRED_DIFFICULTY_FIVE;
import static org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReportCalculationField.DESIRED_DIFFICULTY_FOUR;
import static org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReportCalculationField.DESIRED_DIFFICULTY_ONE;
import static org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReportCalculationField.DESIRED_DIFFICULTY_THREE;
import static org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReportCalculationField.DESIRED_DIFFICULTY_TWO;

/**
 * Build the Gap Report as an MS Excel file.
 */
@Component
public class GapReportBuilder {
    // A map of the search filter fields and their display labels
    private static Map<String, String> columnNameToLabelMap = new HashMap<>();

    static {
        columnNameToLabelMap.put(INTENDED_GRADE.getProperty().toLowerCase(), "Intended Grade");
        columnNameToLabelMap.put(SUBJECT.getProperty().toLowerCase(), "Subject");
        columnNameToLabelMap.put(DOK.getProperty().toLowerCase(), "Depth of Knowledge");
        columnNameToLabelMap.put(WORKFLOW_STATUS.getProperty().toLowerCase(), "Workflow Status");
        columnNameToLabelMap.put(ITEM_TYPE.getProperty().toLowerCase(), "Type");
        columnNameToLabelMap.put(ORGANIZATION_TYPE_ID.getProperty().toLowerCase(), "Organization Type ID");
        columnNameToLabelMap.put(ORGANIZATION_NAME.getProperty().toLowerCase(), "Organization Name");
        columnNameToLabelMap.put(ITEM_AUTHOR.getProperty().toLowerCase(), "Item Author");
        columnNameToLabelMap.put(ITEM_DIFFICULTY_QUINTILE.getProperty().toLowerCase(), "Item Difficulty Quintile");
        columnNameToLabelMap.put(TEST_CATEGORY.getProperty().toLowerCase(), "Test Category");
        columnNameToLabelMap.put(PRIMARY_CLAIM.getProperty().toLowerCase(), "Primary Claim");
        columnNameToLabelMap.put(PRIMARY_TARGET.getProperty().toLowerCase(), "Primary Target");
        columnNameToLabelMap.put(PRIMARY_CONTENT_DOMAIN.getProperty().toLowerCase(), "Primary Content Domain");
        columnNameToLabelMap.put(PRIMARY_COMMON_CORE_STANDARD.getProperty().toLowerCase(), "Primary Common Core Standard");
        columnNameToLabelMap.put(SECONDARY_CLAIM.getProperty().toLowerCase(), "Secondary Claim");
        columnNameToLabelMap.put(SECONDARY_TARGET.getProperty().toLowerCase(), "Secondary Target");
        columnNameToLabelMap.put(SECONDARY_CONTENT_DOMAIN.getProperty().toLowerCase(), "Secondary Content Domain");
        columnNameToLabelMap.put(SECONDARY_COMMON_CORE_STANDARD.getProperty().toLowerCase(), "Secondary Common Core Standard");
        columnNameToLabelMap.put(TERTIARY_CLAIM.getProperty().toLowerCase(), "Tertiary Claim");
        columnNameToLabelMap.put(TERTIARY_TARGET.getProperty().toLowerCase(), "Tertiary Target");
        columnNameToLabelMap.put(TERTIARY_CONTENT_DOMAIN.getProperty().toLowerCase(), "Tertiary Content Domain");
        columnNameToLabelMap.put(TERTIARY_COMMON_CORE_STANDARD.getProperty().toLowerCase(), "Tertiary Common Core Standard");
        columnNameToLabelMap.put(QUATERNARY_CLAIM.getProperty().toLowerCase(), "Quaternary Claim");
        columnNameToLabelMap.put(QUATERNARY_TARGET.getProperty().toLowerCase(), "Quaternary Target");
        columnNameToLabelMap.put(QUATERNARY_CONTENT_DOMAIN.getProperty().toLowerCase(), "Quaternary Content Domain");
        columnNameToLabelMap.put(QUATERNARY_COMMON_CORE_STANDARD.getProperty().toLowerCase(), "Quaternary Common Core Standard");
        columnNameToLabelMap.put(CONTENT_CHANGED_AFTER_OPERATIONAL.getProperty().toLowerCase(), "Has content changed after Operational");
        columnNameToLabelMap.put(HAS_UNRESOLVED_UPDATE_NEED.getProperty().toLowerCase(), "Has unresolved update need");
        columnNameToLabelMap.put(CURRENT_UPDATE_NEED_INTERNAL_RESOLUTION.getProperty().toLowerCase(), "Current update need internal resolution");
        columnNameToLabelMap.put(CURRENT_UPDATE_NEED_RESOLUTION.getProperty().toLowerCase(), "Current update need resolution");
        columnNameToLabelMap.put(ENGLISH_GLOSSARY_PROVIDED.getProperty().toLowerCase(), "Is English Glossary Provided");
        columnNameToLabelMap.put(ILLUSTRATED_GLOSSARY_PROVIDED.getProperty().toLowerCase(), "Is Illustrated Glossary Provided");
        columnNameToLabelMap.put(ILLUSTRATED_GLOSSARY_REQUIRED.getProperty().toLowerCase(), "Is Illustrated Glossary Required");
        columnNameToLabelMap.put(TRANSLATED_GLOSSARY_PROVIDED.getProperty().toLowerCase(), "Is Translated Glossary Provided");
        columnNameToLabelMap.put(TRANSLATED_GLOSSARY_REQUIRED.getProperty().toLowerCase(), "Is Illustrated Glossary Required");
        columnNameToLabelMap.put(DESIRED_DIFFICULTY_COUNT.getFieldName().toLowerCase(), "Desired");
        columnNameToLabelMap.put(DESIRED_DIFFICULTY_ONE.getFieldName().toLowerCase(), "Desired Difficulty 1");
        columnNameToLabelMap.put(DESIRED_DIFFICULTY_TWO.getFieldName().toLowerCase(), "Desired Difficulty 2");
        columnNameToLabelMap.put(DESIRED_DIFFICULTY_THREE.getFieldName().toLowerCase(), "Desired Difficulty 3");
        columnNameToLabelMap.put(DESIRED_DIFFICULTY_FOUR.getFieldName().toLowerCase(), "Desired Difficulty 4");
        columnNameToLabelMap.put(DESIRED_DIFFICULTY_FIVE.getFieldName().toLowerCase(), "Desired Difficulty 5");
        columnNameToLabelMap.put(ACTUAL_DIFFICULTY_COUNT.getFieldName().toLowerCase(), "Actual");
        columnNameToLabelMap.put(ACTUAL_DIFFICULTY_ONE.getFieldName().toLowerCase(), "Actual Difficulty 1");
        columnNameToLabelMap.put(ACTUAL_DIFFICULTY_TWO.getFieldName().toLowerCase(), "Actual Difficulty 2");
        columnNameToLabelMap.put(ACTUAL_DIFFICULTY_THREE.getFieldName().toLowerCase(), "Actual Difficulty 3");
        columnNameToLabelMap.put(ACTUAL_DIFFICULTY_FOUR.getFieldName().toLowerCase(), "Actual Difficulty 4");
        columnNameToLabelMap.put(ACTUAL_DIFFICULTY_FIVE.getFieldName().toLowerCase(), "Actual Difficulty 5");
        columnNameToLabelMap.put(DELTA_DIFFICULTY_COUNT.getFieldName().toLowerCase(), "Delta");
        columnNameToLabelMap.put(DELTA_DIFFICULTY_ONE.getFieldName().toLowerCase(), "Delta Difficulty 1");
        columnNameToLabelMap.put(DELTA_DIFFICULTY_TWO.getFieldName().toLowerCase(), "Delta Difficulty 2");
        columnNameToLabelMap.put(DELTA_DIFFICULTY_THREE.getFieldName().toLowerCase(), "Delta Difficulty 3");
        columnNameToLabelMap.put(DELTA_DIFFICULTY_FOUR.getFieldName().toLowerCase(), "Delta Difficulty 4");
        columnNameToLabelMap.put(DELTA_DIFFICULTY_FIVE.getFieldName().toLowerCase(), "Delta Difficulty 5");
    }

    private final String CELL_STYLE_BOLD_TEXT = "boldText";
    private final String CELL_STYLE_NO_RECORDS = "italicText";
    private final String CELL_STYLE_REPORT_DETAILS_HEADER = "reportDetailsHeader";

    /**
     * Create an Excel workbook for the Gap Report data.
     *
     * @param gapReport The {@link org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReport} containing the data that
     *                  should be displayed on the report.
     * @return An {@link org.apache.poi.xssf.usermodel.XSSFWorkbook} containing the report parameters and report details
     * from the {@link org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReport}
     */
    public XSSFWorkbook getReport(final GapReport gapReport) {
        final XSSFWorkbook gapReportWorkbook = new XSSFWorkbook();
        final Map<String, XSSFCellStyle> cellStyleMap = getStyles(gapReportWorkbook);

        // -------------------------------------------------------------------------------------------------------------
        // REPORT PARAMETERS SHEET
        // -------------------------------------------------------------------------------------------------------------
        final XSSFSheet reportParametersSheet = gapReportWorkbook.createSheet("Report Parameters");

        // Add date row
        final XSSFRow createdDateRow = reportParametersSheet.createRow(0);
        final XSSFCell createDateLabelCell = createdDateRow.createCell(0);
        final XSSFCell createdDateCell = createdDateRow.createCell(1);

        createDateLabelCell.setCellValue("Date Created");
        createDateLabelCell.setCellStyle(cellStyleMap.get(CELL_STYLE_BOLD_TEXT));
        createdDateCell.setCellValue(Date.from(gapReport.getCreatedDate()).toString());

        // Add search filters
        final XSSFRow filtersHeaderRow = reportParametersSheet.createRow(reportParametersSheet.getLastRowNum() + 1);
        final XSSFCell filtersHeaderLabelCell = filtersHeaderRow.createCell(0);
        filtersHeaderLabelCell.setCellValue("Filters");
        filtersHeaderLabelCell.setCellStyle(cellStyleMap.get(CELL_STYLE_BOLD_TEXT));

        if (!gapReport.getFilters().isEmpty()) {
            for (final SearchFilter filter : gapReport.getFilters()) {
                final String joinedFilterValues = getFilterValues(filter).stream()
                        .collect(Collectors.joining(", "));

                // Put the first filter on the same row as the "Subjects" header, all other filters should be in the
                // same column beneath the first.  That is, the fitler's name should be in column B and the joined
                // filter values should be in column C.
                if (filtersHeaderRow.getLastCellNum() == 1) {
                    final XSSFCell filterNameCell = filtersHeaderRow.createCell(filtersHeaderRow.getLastCellNum());
                    filterNameCell.setCellValue(columnNameToLabelMap.get(filter.getFilterProperty().getProperty().toLowerCase()));

                    final XSSFCell filterValueCell = filtersHeaderRow.createCell(filtersHeaderRow.getLastCellNum());
                    filterValueCell.setCellValue(joinedFilterValues);
                } else {
                    final XSSFRow filterRow = reportParametersSheet.createRow(reportParametersSheet.getLastRowNum() + 1);
                    final XSSFCell filterNameCell = filterRow.createCell(1);
                    filterNameCell.setCellValue(columnNameToLabelMap.get(filter.getFilterProperty().getProperty().toLowerCase()));

                    final XSSFCell filterValuesCell = filterRow.createCell(filterRow.getLastCellNum());
                    filterValuesCell.setCellValue(joinedFilterValues);
                }
            }
        } else {
            // add a row to indicate no filters were provided
            final XSSFCell noRecordsCell = filtersHeaderRow.createCell(filtersHeaderRow.getLastCellNum());
            noRecordsCell.setCellValue("No search filters provided");
            noRecordsCell.setCellStyle(cellStyleMap.get(CELL_STYLE_NO_RECORDS));
        }

        // Add groups
        int groupRowIndex = reportParametersSheet.getLastRowNum() + 1;
        final XSSFRow groupsHeaderRow = reportParametersSheet.createRow(groupRowIndex);
        final XSSFCell groupsHeaderCell = groupsHeaderRow.createCell(0);
        groupsHeaderCell.setCellValue("Groups");
        groupsHeaderCell.setCellStyle(cellStyleMap.get(CELL_STYLE_BOLD_TEXT));

        for (final SearchProperty group : gapReport.getGroupFilters()) {
            if (groupsHeaderRow.getLastCellNum() == 1) {
                final XSSFCell firstGroupValueCell = groupsHeaderRow.createCell(groupsHeaderRow.getLastCellNum());
                firstGroupValueCell.setCellValue(group.getProperty());
            } else {
                final XSSFRow groupRow = reportParametersSheet.createRow(++groupRowIndex);
                final XSSFCell groupCell = groupRow.createCell(1);
                groupCell.setCellValue(columnNameToLabelMap.get(group.getProperty().toLowerCase()));
            }
        }

        reportParametersSheet.autoSizeColumn(0);
        reportParametersSheet.autoSizeColumn(1);

        // -------------------------------------------------------------------------------------------------------------
        // REPORT DETAILS SHEET
        // -------------------------------------------------------------------------------------------------------------
        final XSSFSheet reportSheet = gapReportWorkbook.createSheet("Report");

        if (gapReport.getGapReportRecords().isEmpty()) {
            final XSSFRow noRecordsRow = reportSheet.createRow(0);
            final XSSFCell noRecordsCell = noRecordsRow.createCell(0);
            noRecordsCell.setCellValue("No records were found for the provided filters.  Please review the filters, make changes to the specified filter values and try again.");
            noRecordsCell.setCellStyle(cellStyleMap.get(CELL_STYLE_NO_RECORDS));

            return gapReportWorkbook;
        }

        for (int i = 0; i < gapReport.getGapReportRecords().size(); i++) {
            if (i == 0) {
                createReportHeaderRow(reportSheet, gapReport.getGapReportRecords().get(i).keySet(),
                        cellStyleMap.get(CELL_STYLE_REPORT_DETAILS_HEADER));

                for (int c = 0; c < reportSheet.getRow(0).getLastCellNum(); c++) {
                    reportSheet.autoSizeColumn(c);
                }
            }

            createReportDetailRow(reportSheet, gapReport.getGapReportRecords().get(i));
        }

        reportSheet.createFreezePane(0, 1);

        applyAlternateRowConditionalFormatting(reportSheet);

        return gapReportWorkbook;
    }

    /**
     * Create a header for the report {@link org.apache.poi.xssf.usermodel.XSSFSheet} containing the names of the
     * columns contained in the report.  The row will be attached to the
     * {@link org.apache.poi.xssf.usermodel.XSSFSheet}.
     *
     * @param xssfSheet The {@link org.apache.poi.xssf.usermodel.XSSFSheet} that will contain the report data
     * @param headers   A {@link java.util.Set} containin all the column header labels
     * @param cellStyle The {@link org.apache.poi.xssf.usermodel.XSSFCellStyle} to apply to each header cell
     */
    private void createReportHeaderRow(final XSSFSheet xssfSheet,
                                       final Set<String> headers,
                                       final XSSFCellStyle cellStyle) {
        final XSSFRow row = xssfSheet.createRow(0);

        headers.forEach(h -> {
            short cellIndex = row.getLastCellNum();
            if (cellIndex < 0) { // row.getLastCellNum() will return -1 if the row does not have any cells
                cellIndex = 0;
            }

            final XSSFCell headerCell = row.createCell(cellIndex);
            headerCell.setCellValue(columnNameToLabelMap.get(h));
            headerCell.setCellStyle(cellStyle);

            xssfSheet.autoSizeColumn(cellIndex);
        });
    }

    /**
     * Create an {@link org.apache.poi.xssf.usermodel.XSSFRow} containing the details of a record from the
     * {@link org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReport}.  The row will be attached to the report
     * details {@link org.apache.poi.xssf.usermodel.XSSFSheet}.
     *
     * @param xssfSheet The {@link org.apache.poi.xssf.usermodel.XSSFSheet} that will contain the report data
     * @param data      A {@link java.util.Map} containing the column header and the value for a row from the
     *                  {@link org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReport}
     */
    private void createReportDetailRow(final XSSFSheet xssfSheet, final Map<String, Object> data) {
        final XSSFRow row = xssfSheet.createRow(xssfSheet.getLastRowNum() + 1);
        final Map<String, Short> desiredAndActualIndexMap = new HashMap<>();

        data.forEach((key, value) -> {
            short cellIndex = row.getLastCellNum();
            if (cellIndex < 0) { // row.getLastCellNum() will return -1 if the row does not have any cells
                cellIndex = 0;
            }

            final XSSFCell detailCell = row.createCell(cellIndex);

            // Add data to the cell
            final String cellContent = Optional.ofNullable(value).isPresent()
                    ? value.toString()
                    : StringUtils.EMPTY;
            if (NumberUtils.isCreatable(cellContent)) {
                detailCell.setCellValue(Double.parseDouble(cellContent));
            } else {
                detailCell.setCellValue(cellContent);
            }

            // Add formulae
            if (key.toLowerCase().startsWith("actual") || key.equals(DESIRED_DIFFICULTY_COUNT.getFieldName().toLowerCase())) {
                desiredAndActualIndexMap.put(key, cellIndex);
            }

            if (key.matches("^[Dd]esired.*[1-5]")) {
                desiredAndActualIndexMap.put(key, cellIndex);
                final Cell desiredCountCell = row.getCell(desiredAndActualIndexMap.get(DESIRED_DIFFICULTY_COUNT.getFieldName().toLowerCase()));
                detailCell.setCellFormula(String.format("IF(ISNUMBER(%1$s),FLOOR(%1$s/5,1),\"\")", desiredCountCell.getAddress().formatAsString()));
            }

            if (key.matches("^([Dd]elta).*")) {
                final Cell desiredCell = row.getCell(desiredAndActualIndexMap.get("desireddifficulty" + key.substring(key.length() - 1)));
                final Cell actualCell = row.getCell(desiredAndActualIndexMap.get("actualdifficulty" + key.substring(key.length() - 1)));
                detailCell.setCellFormula(String.format("IF(AND(ISNUMBER(%1$s),ISNUMBER(%2$s)),%1$s-%2$s,\"\")",
                        actualCell.getAddress(),
                        desiredCell.getAddress()));

                // Add conditional formatting to highlight cells based on the result of actual - desired
                applyActualMinusDesiredCalculationConditionalFormattingRules(xssfSheet, detailCell);
            }
        });
    }

    /**
     * Add conditional formatting to the "Delta" columns of the report {@link org.apache.poi.xssf.usermodel.XSSFSheet}.
     * The conditional format will:
     * <p>
     * -- Change the background color of the "Delta" cell to red if the value is negative
     * -- Change the background color of the "Delta" cell to green if the value is 0 or positive
     *
     * @param xssfSheet  The {@link org.apache.poi.xssf.usermodel.XSSFSheet} that will contain the report data
     * @param detailCell The {@link org.apache.poi.xssf.usermodel.XSSFCell} for one of the "Delta" columns
     */
    private void applyActualMinusDesiredCalculationConditionalFormattingRules(final XSSFSheet xssfSheet,
                                                                              final XSSFCell detailCell) {
        final XSSFSheetConditionalFormatting formatting = xssfSheet.getSheetConditionalFormatting();
        final XSSFConditionalFormattingRule goodDataRule =
                formatting.createConditionalFormattingRule(String.format("AND(ISNUMBER(%1$s),%1$s>=0)",
                        detailCell.getAddress().formatAsString()));
        final XSSFPatternFormatting goodDataRulePatternFormatting = goodDataRule.createPatternFormatting();
        final XSSFColor goodDataBackgroundColor = new XSSFColor(new byte[]{(byte) 204, (byte) 255, (byte) 204}, null);
        final XSSFFontFormatting goodDataRuleFontFormatting = goodDataRule.createFontFormatting();
        goodDataRuleFontFormatting.setFontColorIndex(IndexedColors.GREEN.getIndex());
        goodDataRulePatternFormatting.setFillBackgroundColor(goodDataBackgroundColor);

        final XSSFConditionalFormattingRule badDataRule =
                formatting.createConditionalFormattingRule(String.format("AND(ISNUMBER(%1$s),%1$s<0)",
                        detailCell.getAddress().formatAsString()));
        final XSSFPatternFormatting badDataRulePatternFormatting = badDataRule.createPatternFormatting();
        final XSSFColor badDataBackgroundColor = new XSSFColor(new byte[]{(byte) 255, (byte) 204, (byte) 204}, null);
        final XSSFFontFormatting badDataRuleFontFormatting = badDataRule.createFontFormatting();
        badDataRuleFontFormatting.setFontColorIndex(IndexedColors.RED.getIndex());
        badDataRuleFontFormatting.setFontStyle(true, true);
        badDataRulePatternFormatting.setFillBackgroundColor(badDataBackgroundColor);

        final CellRangeAddress[] cellRange = {
                CellRangeAddress.valueOf(detailCell.getAddress().formatAsString() + ":" + detailCell.getAddress().formatAsString())
        };

        formatting.addConditionalFormatting(cellRange, goodDataRule);
        formatting.addConditionalFormatting(cellRange, badDataRule);
    }

    /**
     * Apply an alternating row color to a {@link org.apache.poi.xssf.usermodel.XSSFSheet}.
     *
     * @param xssfSheet The {@link org.apache.poi.xssf.usermodel.XSSFSheet} that should have an alternating row color
     *                  applied
     */
    private void applyAlternateRowConditionalFormatting(final XSSFSheet xssfSheet) {
        final CellRangeAddress[] allCells = {new CellRangeAddress(0,
                xssfSheet.getLastRowNum(), 0,
                xssfSheet.getRow(xssfSheet.getLastRowNum()).getLastCellNum() - 1)};

        final XSSFSheetConditionalFormatting formatting = xssfSheet.getSheetConditionalFormatting();
        final XSSFConditionalFormattingRule alternatingRowRule = formatting.createConditionalFormattingRule("MOD(ROW(),2)=0");
        final XSSFPatternFormatting alternatingRowRulePatternFormatting = alternatingRowRule.createPatternFormatting();
        final XSSFColor whitesmoke = new XSSFColor(new byte[]{(byte) 245, (byte) 245, (byte) 245}, null);
        alternatingRowRulePatternFormatting.setFillBackgroundColor(whitesmoke);

        formatting.addConditionalFormatting(allCells, alternatingRowRule);
    }

    /**
     * Extract filter values from a {@link org.opentestsystem.ap.imrt.iss.model.SearchFilter}.
     *
     * @param filter The {@link org.opentestsystem.ap.imrt.iss.model.SearchFilter} to get values from
     * @return A {@link java.util.List} of {@link java.lang.String}s containing the values of the search filters passed
     * into the {@link org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReport}
     */
    private List<String> getFilterValues(final SearchFilter filter) {
        List<String> searchFilterValues;

        // No need for FormMatchSearchFilter; nothing with forms supports counts
        if (filter instanceof BooleanFlagSearchFilter) {
            searchFilterValues = Collections.singletonList(String.valueOf(((BooleanFlagSearchFilter) filter).getFlag()));
        } else if (filter instanceof ContainsSearchFilter) {
            searchFilterValues = ((ContainsSearchFilter) filter).getFilterValues();
        } else if (filter instanceof DateRangeSearchFilter) {
            final DateRangeSearchFilter dateRangeSearchFilter = (DateRangeSearchFilter) filter;
            searchFilterValues = Arrays.asList(String.format("from: %s", dateRangeSearchFilter.getFrom()),
                    String.format("to: %s", dateRangeSearchFilter.getTo()));
        } else if (filter instanceof DaysBetweenSearchFilter) {
            final DaysBetweenSearchFilter daysBetweenSearchFilter = (DaysBetweenSearchFilter) filter;
            searchFilterValues = Arrays.asList(String.format("min: %d", daysBetweenSearchFilter.getMin()),
                    String.format("max: %d", daysBetweenSearchFilter.getMax()));
        } else if (filter instanceof IdMatchSearchFilter) {
            searchFilterValues = ((IdMatchSearchFilter) filter).getFilterValues();
        } else if (filter instanceof IntegerRangeSearchFilter) {
            final IntegerRangeSearchFilter integerRangeSearchFilter = (IntegerRangeSearchFilter) filter;
            searchFilterValues = Collections.singletonList(String.format("min = %d, max = %d",
                    integerRangeSearchFilter.getMin(),
                    integerRangeSearchFilter.getMax()));
        } else if (filter instanceof MatchSearchFilter) {
            searchFilterValues = ((MatchSearchFilter) filter).getFilterValues();
        } else {
            searchFilterValues = Collections.emptyList();
        }

        return searchFilterValues;
    }

    /**
     * Get a collection of {@link org.apache.poi.xssf.usermodel.XSSFCellStyle}s to apply to the
     * {@link org.apache.poi.xssf.usermodel.XSSFSheet}s in the report.
     *
     * @param xssfWorkbook The {@link org.apache.poi.xssf.usermodel.XSSFWorkbook} that owns the styles
     * @return A {@link java.util.Map} of {@link String}s and {@link org.apache.poi.xssf.usermodel.XSSFCellStyle}s that
     * can be applied to the report.
     */
    private Map<String, XSSFCellStyle> getStyles(final XSSFWorkbook xssfWorkbook) {
        final Map<String, XSSFCellStyle> cellStyleMap = new HashMap<>();

        xssfWorkbook.getCellStyleAt(0).getFont().setFontHeightInPoints((short) 12);
        final String fontName = xssfWorkbook.getCellStyleAt(0).getFont().getFontName();
        final short fontHeight = xssfWorkbook.getCellStyleAt(0).getFont().getFontHeight();

        final XSSFFont boldFont = xssfWorkbook.createFont();
        boldFont.setBold(true);
        boldFont.setFontName(fontName);
        boldFont.setFontHeight(fontHeight);

        final XSSFFont noRecordFont = xssfWorkbook.createFont();
        noRecordFont.setItalic(true);
        noRecordFont.setFontName(fontName);
        noRecordFont.setColor(IndexedColors.GREY_50_PERCENT.index);

        final XSSFFont reportHeaderFont = xssfWorkbook.createFont();
        reportHeaderFont.setBold(true);
        reportHeaderFont.setFontHeightInPoints((short) 16);
        reportHeaderFont.setColor(IndexedColors.GREY_80_PERCENT.index);

        final XSSFCellStyle boldTextCellStyle = xssfWorkbook.createCellStyle();
        boldTextCellStyle.setFont(boldFont);

        final XSSFCellStyle noRecordCellStyle = xssfWorkbook.createCellStyle();
        noRecordCellStyle.setFont(noRecordFont);

        final XSSFCellStyle reportDetailsHeaderCellStyle = xssfWorkbook.createCellStyle();
        reportDetailsHeaderCellStyle.setFont(reportHeaderFont);
        reportDetailsHeaderCellStyle.setBorderTop(BorderStyle.NONE);
        reportDetailsHeaderCellStyle.setBorderRight(BorderStyle.NONE);
        reportDetailsHeaderCellStyle.setBorderLeft(BorderStyle.NONE);
        reportDetailsHeaderCellStyle.setBorderBottom(BorderStyle.THICK);
        reportDetailsHeaderCellStyle.setBorderColor(XSSFCellBorder.BorderSide.BOTTOM,
                new XSSFColor(new byte[]{(byte) 70, (byte) 130, (byte) 180},
                        new DefaultIndexedColorMap()));

        cellStyleMap.put(CELL_STYLE_BOLD_TEXT, boldTextCellStyle);
        cellStyleMap.put(CELL_STYLE_NO_RECORDS, noRecordCellStyle);
        cellStyleMap.put(CELL_STYLE_REPORT_DETAILS_HEADER, reportDetailsHeaderCellStyle);

        return cellStyleMap;
    }
}
