package org.opentestsystem.ap.imrt.iss.model.reports.gap;

import org.apache.commons.lang.StringUtils;
import org.apache.poi.xssf.usermodel.XSSFCell;
import org.apache.poi.xssf.usermodel.XSSFCellStyle;
import org.apache.poi.xssf.usermodel.XSSFColor;
import org.apache.poi.xssf.usermodel.XSSFFont;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty;
import org.opentestsystem.ap.imrt.iss.model.BooleanFlagSearchFilter;
import org.opentestsystem.ap.imrt.iss.model.ContainsSearchFilter;
import org.opentestsystem.ap.imrt.iss.model.DateRangeSearchFilter;
import org.opentestsystem.ap.imrt.iss.model.DaysBetweenSearchFilter;
import org.opentestsystem.ap.imrt.iss.model.IdMatchSearchFilter;
import org.opentestsystem.ap.imrt.iss.model.IntegerRangeSearchFilter;
import org.opentestsystem.ap.imrt.iss.model.MatchSearchFilter;
import org.opentestsystem.ap.imrt.iss.model.SearchFilter;

import java.awt.Color;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.CONTENT_CHANGED_AFTER_OPERATIONAL;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.CURRENT_UPDATE_NEED_INTERNAL_RESOLUTION;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.CURRENT_UPDATE_NEED_RESOLUTION;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.DOK;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.ENGLISH_GLOSSARY_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.HAS_UNRESOLVED_UPDATE_NEED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.ILLUSTRATED_GLOSSARY_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.ILLUSTRATED_GLOSSARY_REQUIRED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.INTENDED_GRADE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.ITEM_AUTHOR;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.ITEM_DIFFICULTY_QUINTILE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.ITEM_TYPE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.ORGANIZATION_NAME;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.ORGANIZATION_TYPE_ID;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.PRIMARY_CLAIM;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.PRIMARY_COMMON_CORE_STANDARD;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.PRIMARY_CONTENT_DOMAIN;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.PRIMARY_TARGET;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.QUATERNARY_CLAIM;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.QUATERNARY_COMMON_CORE_STANDARD;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.QUATERNARY_CONTENT_DOMAIN;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.QUATERNARY_TARGET;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.SECONDARY_CLAIM;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.SECONDARY_COMMON_CORE_STANDARD;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.SECONDARY_CONTENT_DOMAIN;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.SECONDARY_TARGET;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.SUBJECT;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.TERTIARY_CLAIM;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.TERTIARY_COMMON_CORE_STANDARD;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.TERTIARY_CONTENT_DOMAIN;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.TERTIARY_TARGET;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.TEST_CATEGORY;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.TRANSLATED_GLOSSARY_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.TRANSLATED_GLOSSARY_REQUIRED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.WORKFLOW_STATUS;

public class GapReportBuilder {
    private static Map<String, String> columnNameToLabelMap = new HashMap<>();
    static {
        columnNameToLabelMap.put(INTENDED_GRADE.getColumnName(), "Intended Grade");
        columnNameToLabelMap.put(SUBJECT.getColumnName(), "Subject");
        columnNameToLabelMap.put(DOK.getColumnName(), "Depth of Knowledge");
        columnNameToLabelMap.put(WORKFLOW_STATUS.getColumnName(), "Workflow Status");
        columnNameToLabelMap.put(ITEM_TYPE.getColumnName(), "Type");
        columnNameToLabelMap.put(ORGANIZATION_TYPE_ID.getColumnName(), "Organization Type ID");
        columnNameToLabelMap.put(ORGANIZATION_NAME.getColumnName(), "Organization Name");
        columnNameToLabelMap.put(ITEM_AUTHOR.getColumnName(), "Item Author");
        columnNameToLabelMap.put(ITEM_DIFFICULTY_QUINTILE.getColumnName(), "Item Difficulty Quintile");
        columnNameToLabelMap.put(TEST_CATEGORY.getColumnName(), "Test Category");
        columnNameToLabelMap.put(PRIMARY_CLAIM.getColumnName(), "Primary Claim");
        columnNameToLabelMap.put(PRIMARY_TARGET.getColumnName(), "Primary Target");
        columnNameToLabelMap.put(PRIMARY_CONTENT_DOMAIN.getColumnName(), "Primary Content Domain");
        columnNameToLabelMap.put(PRIMARY_COMMON_CORE_STANDARD.getColumnName(), "Primary Common Core Standard");
        columnNameToLabelMap.put(SECONDARY_CLAIM.getColumnName(), "Secondary Claim");
        columnNameToLabelMap.put(SECONDARY_TARGET.getColumnName(), "Secondary Target");
        columnNameToLabelMap.put(SECONDARY_CONTENT_DOMAIN.getColumnName(), "Secondary Content Domain");
        columnNameToLabelMap.put(SECONDARY_COMMON_CORE_STANDARD.getColumnName(), "Secondary Common Core Standard");
        columnNameToLabelMap.put(TERTIARY_CLAIM.getColumnName(), "Tertiary Claim");
        columnNameToLabelMap.put(TERTIARY_TARGET.getColumnName(), "Tertiary Target");
        columnNameToLabelMap.put(TERTIARY_CONTENT_DOMAIN.getColumnName(), "Tertiary Content Domain");
        columnNameToLabelMap.put(TERTIARY_COMMON_CORE_STANDARD.getColumnName(), "Tertiary Common Core Standard");
        columnNameToLabelMap.put(QUATERNARY_CLAIM.getColumnName(), "Quaternary Claim");
        columnNameToLabelMap.put(QUATERNARY_TARGET.getColumnName(),  "Quaternary Target");
        columnNameToLabelMap.put(QUATERNARY_CONTENT_DOMAIN.getColumnName(), "Quaternary Content Domain");
        columnNameToLabelMap.put(QUATERNARY_COMMON_CORE_STANDARD.getColumnName(), "Quaternary Common Core Standard");
        columnNameToLabelMap.put(CONTENT_CHANGED_AFTER_OPERATIONAL.getColumnName(), "Has content changed after Operational");
        columnNameToLabelMap.put(HAS_UNRESOLVED_UPDATE_NEED.getColumnName(), "Has unresolved update need");
        columnNameToLabelMap.put(CURRENT_UPDATE_NEED_INTERNAL_RESOLUTION.getColumnName(), "Current update need internal resolution");
        columnNameToLabelMap.put(CURRENT_UPDATE_NEED_RESOLUTION.getColumnName(), "Current update need resolution");
        columnNameToLabelMap.put(ENGLISH_GLOSSARY_PROVIDED.getColumnName(), "Is English Glossary Provided");
        columnNameToLabelMap.put(ILLUSTRATED_GLOSSARY_PROVIDED.getColumnName(), "Is Illustrated Glossary Provided");
        columnNameToLabelMap.put(ILLUSTRATED_GLOSSARY_REQUIRED.getColumnName(), "Is Illustrated Glossary Required");
        columnNameToLabelMap.put(TRANSLATED_GLOSSARY_PROVIDED.getColumnName(), "Is Translated Glossary Provided");
        columnNameToLabelMap.put(TRANSLATED_GLOSSARY_REQUIRED.getColumnName(), "Is Illustrated Glossary Required");
        columnNameToLabelMap.put("desired_difficulty_count", "Desired");
        columnNameToLabelMap.put("desired_difficulty_1", "Desired Difficulty 1");
        columnNameToLabelMap.put("desired_difficulty_2", "Desired Difficulty 2");
        columnNameToLabelMap.put("desired_difficulty_3", "Desired Difficulty 3");
        columnNameToLabelMap.put("desired_difficulty_4", "Desired Difficulty 4");
        columnNameToLabelMap.put("desired_difficulty_5", "Desired Difficulty 5");
        columnNameToLabelMap.put("actual_difficulty_count", "Actual");
        columnNameToLabelMap.put("actual_difficulty_1", "Actual Difficulty 1");
        columnNameToLabelMap.put("actual_difficulty_2", "Actual Difficulty 2");
        columnNameToLabelMap.put("actual_difficulty_3", "Actual Difficulty 3");
        columnNameToLabelMap.put("actual_difficulty_4", "Actual Difficulty 4");
        columnNameToLabelMap.put("actual_difficulty_5", "Actual Difficulty 5");
        columnNameToLabelMap.put("delta_difficulty_count", "Delta");
        columnNameToLabelMap.put("delta_difficulty_1", "Delta Difficulty 1");
        columnNameToLabelMap.put("delta_difficulty_2", "Delta Difficulty 2");
        columnNameToLabelMap.put("delta_difficulty_3", "Delta Difficulty 3");
        columnNameToLabelMap.put("delta_difficulty_4", "Delta Difficulty 4");
        columnNameToLabelMap.put("delta_difficulty_5", "Delta Difficulty 5");
    }

    public void getReport(final GapReport gapReport) throws IOException {
        final Map<String, Short> difficultyQuintileColumnIndices = new HashMap<>();

        final XSSFWorkbook gapReportWorkbook = new XSSFWorkbook();
        gapReportWorkbook.getCellStyleAt(0).getFont().setFontHeightInPoints((short) 12);

        final XSSFFont boldFont = gapReportWorkbook.createFont();
        boldFont.setBold(true);
        boldFont.setFontName(gapReportWorkbook.getCellStyleAt(0).getFont().getFontName());
        boldFont.setFontHeight(gapReportWorkbook.getCellStyleAt(0).getFont().getFontHeight());
        final XSSFFont italicFont = gapReportWorkbook.createFont();
        italicFont.setItalic(true);
        italicFont.setFontName(gapReportWorkbook.getCellStyleAt(0).getFont().getFontName());
        italicFont.setColor(new XSSFColor(Color.GRAY));

        // -------------------------------------------------------------------------------------------------------------
        // REPORT PARAMETERS SHEET
        // -------------------------------------------------------------------------------------------------------------
        final XSSFSheet reportParametersSheet = gapReportWorkbook.createSheet("Report Parameters");

        // Add date row
        final XSSFRow createdDateRow = reportParametersSheet.createRow(0);
        final XSSFCell createDateLabelCell = createdDateRow.createCell(0);
        final XSSFCell createdDateCell = createdDateRow.createCell(1);

        final XSSFCellStyle boldTextCellStyle = gapReportWorkbook.createCellStyle();
        boldTextCellStyle.setFont(boldFont);
        final XSSFCellStyle italicTextCellStyle = gapReportWorkbook.createCellStyle();
        italicTextCellStyle.setFont(italicFont);
        italicTextCellStyle.setFillForegroundColor(new XSSFColor(Color.GRAY));

        createDateLabelCell.setCellValue("Date Created");
        createDateLabelCell.setCellStyle(boldTextCellStyle);
        createdDateCell.setCellValue(Date.from(gapReport.getCreatedDate()).toString());

        // Add search filters
        final XSSFRow filtersHeaderRow = reportParametersSheet.createRow(reportParametersSheet.getLastRowNum() + 1);
        final XSSFCell filtersHeaderLabelCell = filtersHeaderRow.createCell(0);
        filtersHeaderLabelCell.setCellValue("Filters");
        filtersHeaderLabelCell.setCellStyle(boldTextCellStyle);

        if (!gapReport.getFilters().isEmpty()) {
            for (final SearchFilter filter : gapReport.getFilters()) {
                if (filtersHeaderRow.getLastCellNum() == 1) {
                    final XSSFCell firstFilterLabelCell = filtersHeaderRow.createCell(filtersHeaderRow.getLastCellNum());
                    firstFilterLabelCell.setCellValue(columnNameToLabelMap.get(filter.getFilterProperty().getColumnName()));

                    final List<String> filterValues = getFilterValues(filter);

                    int subsequentFilterValuesRowIndex = filtersHeaderRow.getRowNum();
                    for (int i = 0; i < filterValues.size(); i++) {
                        if (i == 0) {
                            final XSSFCell firstFilterValueCell = filtersHeaderRow.createCell(filtersHeaderRow.getLastCellNum());
                            firstFilterValueCell.setCellValue(filterValues.get(0));
                        } else {
                            final XSSFRow filterValueRow = reportParametersSheet.createRow(++subsequentFilterValuesRowIndex);
                            final XSSFCell filterValueCell = filterValueRow.createCell(2);
                            filterValueCell.setCellValue(filterValues.get(i));
                        }
                    }
                } else {
                    final List<String> filterValues = getFilterValues(filter);
                    final XSSFRow filterRow = reportParametersSheet.createRow(reportParametersSheet.getLastRowNum() + 1);
                    XSSFCell filterLabelCell = filterRow.createCell(1);
                    filterLabelCell.setCellValue(columnNameToLabelMap.get(filter.getFilterProperty().getColumnName()));

                    int subsequentFilterValuesRowIndex = filterRow.getRowNum();
                    for (int i = 0; i < filterValues.size(); i++) {
                        if (i == 0) {
                            final XSSFCell firstFilterValueCell = filterRow.createCell(2);
                            firstFilterValueCell.setCellValue(filterValues.get(0));
                        } else {
                            final XSSFRow filterValueRow = reportParametersSheet.createRow(++subsequentFilterValuesRowIndex);
                            final XSSFCell filterValueCell = filterValueRow.createCell(2);
                            filterValueCell.setCellValue(filterValues.get(i));
                        }
                    }
                }
            }
        } else {
            // add a row to indicate no filters were provided
            filtersHeaderLabelCell.setCellValue("No search filters provided");
            filtersHeaderLabelCell.setCellStyle(italicTextCellStyle);
        }

        int groupRowIndex = reportParametersSheet.getLastRowNum() + 1;
        final XSSFRow groupsHeaderRow = reportParametersSheet.createRow(groupRowIndex);
        final XSSFCell groupsHeaderCell = groupsHeaderRow.createCell(0);
        groupsHeaderCell.setCellValue("Groups");
        groupsHeaderCell.setCellStyle(boldTextCellStyle);

        for (final SearchProperty group : gapReport.getGroupFilters()) {
            if (groupsHeaderRow.getLastCellNum() == 1) {
                final XSSFCell firstGroupValueCell = groupsHeaderRow.createCell(groupsHeaderRow.getLastCellNum());
                firstGroupValueCell.setCellValue(group.getProperty());
            } else {
                final XSSFRow groupRow = reportParametersSheet.createRow(++groupRowIndex);
                final XSSFCell groupCell = groupRow.createCell(1);
                groupCell.setCellValue(group.getProperty());
            }
        }

        reportParametersSheet.autoSizeColumn(0);
        reportParametersSheet.autoSizeColumn(1);
        reportParametersSheet.autoSizeColumn(2);

        // -------------------------------------------------------------------------------------------------------------
        // REPORT DETAILS SHEET
        // -------------------------------------------------------------------------------------------------------------
        final XSSFSheet reportSheet = gapReportWorkbook.createSheet("Report");

        for (int i = 0; i < gapReport.getGapReportRecords().size(); i++) {
            if (i == 0) {
                final XSSFRow headerRow = reportSheet.createRow(0);
                // TODO:  Get "english" labels for headers
                for (final String headerText : gapReport.getGapReportRecords().get(i).keySet()) {
                    short cellIndex = headerRow.getLastCellNum();
                    if (cellIndex < 0) {
                        cellIndex = 0;
                    }

                    final XSSFCell headerCell = headerRow.createCell(cellIndex);
                    headerCell.setCellValue(columnNameToLabelMap.get(headerText));
                    headerCell.setCellStyle(boldTextCellStyle);

                    if (headerText.toLowerCase().matches("(actual|desired)(.+)")) {
                        difficultyQuintileColumnIndices.put(headerText, cellIndex);
                    }
                }

                for (int c = 0; c < headerRow.getLastCellNum(); c++) {
                    reportSheet.autoSizeColumn(c);
                }
            }

            final XSSFRow detailRow = reportSheet.createRow(i + 1);
            for (final Object value : gapReport.getGapReportRecords().get(i).values()) {
                final String val = Optional.ofNullable(value).isPresent()
                        ? value.toString()
                        : StringUtils.EMPTY;
                short cellIndex = detailRow.getLastCellNum();
                if (cellIndex < 0) {
                    cellIndex = 0;
                }

                final XSSFCell detailCell = detailRow.createCell(cellIndex);
                detailCell.setCellValue(val);
            }

            // TODO: add formula (check requirements) something like [actual difficulty - desired difficulty]
        }

        // write file
        final String excelFileName = "/Users/jeffjohnson/Desktop/test.xlsx";
        final FileOutputStream fileOutputStream = new FileOutputStream(excelFileName);

        gapReportWorkbook.write(fileOutputStream);
        fileOutputStream.flush();
        fileOutputStream.close();
    }

    private List<String> getFilterValues(final SearchFilter filter) {
        List<String> searchFilterValues;

        // No need for FormMatchSearchFilter; nothing with forms supports counts
        if (filter instanceof BooleanFlagSearchFilter) {
            searchFilterValues = Collections.singletonList(String.valueOf(((BooleanFlagSearchFilter) filter).getFlag()));
        } else if (filter instanceof ContainsSearchFilter) {
            searchFilterValues = ((ContainsSearchFilter) filter).getFilterValues();
        } else if (filter instanceof DateRangeSearchFilter) {
            final DateRangeSearchFilter dateRangeSearchFilter = (DateRangeSearchFilter) filter;
            searchFilterValues = Arrays.asList(String.format("from: %s", dateRangeSearchFilter.getFrom()),
                    String.format("to: %s", dateRangeSearchFilter.getTo()));
        } else if (filter instanceof DaysBetweenSearchFilter) {
            final DaysBetweenSearchFilter daysBetweenSearchFilter = (DaysBetweenSearchFilter) filter;
            searchFilterValues = Arrays.asList(String.format("min: %d", daysBetweenSearchFilter.getMin()),
                    String.format("max: %d", daysBetweenSearchFilter.getMax()));
        } else if (filter instanceof IdMatchSearchFilter) {
            searchFilterValues = ((IdMatchSearchFilter) filter).getFilterValues();
        } else if (filter instanceof IntegerRangeSearchFilter) {
            final IntegerRangeSearchFilter integerRangeSearchFilter = (IntegerRangeSearchFilter) filter;
            searchFilterValues = Collections.emptyList(); // TODO:  set filter values
        } else if (filter instanceof MatchSearchFilter) {
            searchFilterValues = ((MatchSearchFilter) filter).getFilterValues();
        } else {
            searchFilterValues = Collections.emptyList();
        }

        return searchFilterValues;
    }
}
