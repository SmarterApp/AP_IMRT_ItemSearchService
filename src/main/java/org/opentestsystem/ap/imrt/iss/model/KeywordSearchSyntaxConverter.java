package org.opentestsystem.ap.imrt.iss.model;

//import org.opentestsystem.ap.imrt.iss.util.javaluator.*;
import com.fathzer.soft.javaluator.*;
import org.springframework.core.convert.converter.Converter;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static org.apache.commons.lang3.StringUtils.isBlank;

/**
 * Converter from KeywordSearchFilter to SQL String for PostgreSQL core.
 */
public class KeywordSearchSyntaxConverter implements Converter<KeywordSearchFilter, String> {

    private static final String POSTGRES_REGEX_SPECIAL_CHARS = "[.+?*^${}()|[]\\";
    private static final String AND_SYMBOL = "&&";
    private static final String OR_SYMBOL = "||";
    private static final String NEGATE_SYMBOL = "~";
    private static final char MULTI_WILDCARD = '*';
    private static final char SINGLE_WILDCARD = '_';


    private static final String ERROR_MESSAGE_PREFIX = "Keyword search error: ";
    private static final String ESCAPED_DOUBLE_QUOTE = "\uF0000";
    private static final String QUOTE_MARKER = "\":";

    private static final Pattern UUID_PATTERN =
            Pattern.compile("[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}");

    @Override
    public String convert(KeywordSearchFilter keywordSearchFilter) {
        if (isBlank(keywordSearchFilter.getValue())) {
            throw new IllegalArgumentException(ERROR_MESSAGE_PREFIX + "search string cannot be blank");
        }

        final String tableName = keywordSearchFilter.getFilterProperty().getTable();
        final String columnName = keywordSearchFilter.getFilterProperty().getColumnName();
        final boolean caseSensitive = keywordSearchFilter.isCaseSensitive();

        Map<String, String> substitutions = new HashMap<>();
        String editedString = extractQuotedStrings(keywordSearchFilter.getValue(), substitutions);

        BooleanEvaluator evaluator = new BooleanEvaluator(tableName, columnName, caseSensitive, substitutions);

        try {
            return evaluator.evaluate(editedString, null);
        } catch (IllegalArgumentException e) {
            if (isBlank(e.getMessage())) {
                String errorMessage =
                        String.format("cannot parse expression. Mismatched %s, %s, or %s.",
                                AND_SYMBOL, OR_SYMBOL, NEGATE_SYMBOL);

                throw new IllegalArgumentException(ERROR_MESSAGE_PREFIX + errorMessage, e);
            } else if (!e.getMessage().startsWith(ERROR_MESSAGE_PREFIX)) {
                throw new IllegalArgumentException(ERROR_MESSAGE_PREFIX + e.getMessage(), e);
            } else {
                throw(e);
            }
        }
    }

    private String extractQuotedStrings(String expression, Map<String,String> extractedStrings) {
        String cleanedExpression = expression
                .replaceAll("\"\"", ESCAPED_DOUBLE_QUOTE);
        StringBuilder editedSearchString = new StringBuilder();
        StringBuilder quoted = new StringBuilder();

        boolean inQuotes = false;

        for (char c : cleanedExpression.toCharArray()) {
            if (inQuotes) {
                if (c == '"') {
                    inQuotes = false;
                    String uuid = UUID.randomUUID().toString();

                    extractedStrings.put(uuid, quoted.toString());
                    editedSearchString.append(uuid);
                    quoted.setLength(0);
                } else {
                    quoted.append(c);
                }
            } else if (c == '"') {
                inQuotes = true;
            } else {
                editedSearchString.append(c);
            }
        }

        if (inQuotes) {
            throw new IllegalArgumentException(ERROR_MESSAGE_PREFIX + "mismatched quotes");
        }

        return editedSearchString.toString();
    }


    private static class BooleanEvaluator extends AbstractEvaluator<String> {

        private final static Operator AND = new Operator(AND_SYMBOL, 2, Operator.Associativity.LEFT, 2);
        private final static Operator OR = new Operator(OR_SYMBOL, 2, Operator.Associativity.LEFT, 1);
        private final static Operator NEGATE = new Operator(NEGATE_SYMBOL, 1, Operator.Associativity.RIGHT, 3);

        private static final Parameters PARAMETERS;

        static {
            PARAMETERS = new Parameters();
            PARAMETERS.add(AND);
            PARAMETERS.add(OR);
            PARAMETERS.add(NEGATE);
            PARAMETERS.addExpressionBracket(BracketPair.BRACES);
        }

        private final String tableName;
        private final String columnName;
        private final boolean caseSensitive;
        private final Map<String, String> substitutions;

        private BooleanEvaluator(String tableName, String columnName, boolean caseSensitive, Map<String, String> substitutions) {
            super(PARAMETERS);
            this.tableName = tableName;
            this.columnName = columnName;
            this.caseSensitive = caseSensitive;
            this.substitutions = substitutions;
        }

        @Override
        protected String toValue(String token, Object evaluationContext) {
            token = (token == null) ? "" : token;
            Matcher matcher = UUID_PATTERN.matcher(token);
            boolean isQuote = false;

            while (matcher.find()) {
                isQuote = true;
                String uuid = matcher.group();
                if (substitutions.containsKey(uuid)) {
                    token = token.replace(uuid, substitutions.get(uuid));
                }
            }

            if (isQuote) {
                token = QUOTE_MARKER + token;
            }

            return convertToken(token);
        }

        @Override
        protected String evaluate(Operator operator,
                                  Iterator<String> operands, Object evaluationContext) {
            String eval = null;
            String o1 = operands.next();
            String o2 = operands.hasNext() ? operands.next() : null;

            if (operator == NEGATE) {
                eval =  "NOT " + o1;
            } else if (operator == OR) {
                eval = "(" + o1 + " OR " + o2 + ")";
            } else if (operator == AND) {
                eval = "(" + o1 + " AND " + o2 + ")";
            }

            return eval;
        }

        private String convertToken(String token) {
            String operator = caseSensitive ? " ~ " : " ~* ";
            return tableName + "." + columnName + operator + "'" + prepareToken(token) + "'";
        }

        private String prepareToken(String token) {
            boolean isQuoted = token.startsWith(QUOTE_MARKER);
            String editedToken = isQuoted ? token.substring(QUOTE_MARKER.length()) : token;
            editedToken = editedToken
                    .replaceAll("\\s+", " ")
                    .trim()
                    .replaceAll(ESCAPED_DOUBLE_QUOTE, "\"");

            StringBuilder sb = new StringBuilder();

            char [] chars = editedToken.toCharArray();

            for (char c : chars) {
                if (c == SINGLE_WILDCARD && !isQuoted) {
                    sb.append("\\S");
                } else if (c == MULTI_WILDCARD && !isQuoted) {
                    sb.append("\\S*");
                } else if (c == '\'') {
                    sb.append("''");
                } else if (POSTGRES_REGEX_SPECIAL_CHARS.indexOf(c) >= 0) {
                    sb.append("\\").append(c);
                } else {
                    sb.append(c);
                }
            }

            return sb.toString();
        }
    }
}
