package org.opentestsystem.ap.imrt.iss.repository;

import org.opentestsystem.ap.imrt.iss.dto.search.PageDto;
import org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty;
import org.opentestsystem.ap.imrt.iss.dto.search.Sort;
import org.opentestsystem.ap.imrt.iss.model.FilterQuery;
import org.opentestsystem.ap.imrt.iss.model.IdMatchSearchFilter;
import org.opentestsystem.ap.imrt.iss.model.KeywordSearchFilter;
import org.opentestsystem.ap.imrt.iss.model.SearchFilter;
import org.opentestsystem.ap.imrt.iss.model.SearchPermissions;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Handles building queries for general search
 */
@Component
public class SearchFilterQueryBuilder {
    private static final Integer MAX_PAGE_SIZE = 1000;

    /**
     * Builds the WHERE query for general search
     *
     * @param maybePageDto  the {@link PageDto} with the page information
     * @param sorts         the {@link Sort} to apply to the results
     * @param searchFilters the {@link SearchFilter} which are used to filter the results
     * @param baseQuery     the base query for the select.  Must include the "FROM item"
     * @return a query leveraging the passed in arguments which will filter, order, page, and sort as appropriate.
     */
    SearchQuery buildQuery(final SearchPermissions searchPermissions,
                           final Optional<PageDto> maybePageDto,
                           final Collection<Sort> sorts,
                           final List<SearchFilter> searchFilters,
                           final String baseQuery) {
        return buildQuery(searchPermissions, maybePageDto, sorts, searchFilters, Optional.empty(), baseQuery);
    }

    /**
     * Builds the WHERE query for general search
     *
     * @param searchFilters the {@link SearchFilter} which are used to filter the results
     * @param baseQuery     the base query for the select.  Must include the "FROM item"
     * @return a query leveraging the passed in arguments which will filter results
     */
    SearchQuery buildQuery(final SearchPermissions searchPermissions,
                           final List<SearchFilter> searchFilters,
                           final String baseQuery) {
        return buildQuery(searchPermissions, Optional.empty(), Collections.emptyList(), searchFilters, Optional.empty(),
            baseQuery);
    }

    /**
     * Builds the WHERE query for general search counts
     *
     * @param searchFilters the {@link SearchFilter} which are used to filter the results
     * @param groupBy       the {@link SearchProperty} to group results for counts
     * @param baseQuery     the base query for the select.  Must include the "FROM item"
     * @return a query leveraging the passed in arguments which will filter, order, page, and sort as appropriate.
     */
    SearchQuery buildQuery(final SearchPermissions searchPermissions,
                           final List<SearchFilter> searchFilters,
                           SearchProperty groupBy,
                           final String baseQuery) {
        return buildQuery(searchPermissions, Optional.empty(), Collections.emptyList(), searchFilters,
            Optional.of(Collections.singletonList(groupBy)), baseQuery);
    }

    /**
     * Builds WHERE query for multiple GROUP BY and ORDER BY fields
     *
     * @param searchFilters the {@link SearchFilter} which are used to filter the results
     * @param groupBy       the {@link SearchProperty}s to group results for counts
     * @param sorts         the {@link Sort}s to apply to the results
     * @param baseQuery     the base query for the select.  Must include the "FROM item"
     * @return a query leveraging the passed in arguments which will filter, order, page, and sort as appropriate.
     */
    SearchQuery buildQuery(final SearchPermissions searchPermissions,
                           final List<SearchFilter> searchFilters,
                           final Collection<SearchProperty> groupBy,
                           final Collection<Sort> sorts,
                           final String baseQuery) {
        return buildQuery(searchPermissions, Optional.empty(), sorts, searchFilters, Optional.of(groupBy), baseQuery);
    }

    /**
     * Builds the WHERE query for general search
     *
     * @param maybePageDto  the {@link PageDto} with the page information
     * @param sorts         the {@link Sort} to apply to the results
     * @param searchFilters the {@link SearchFilter} which are used to filter the results
     * @param maybeGroupBy  the {@link SearchProperty} to group results for counts
     * @param baseQuery     the base query for the select.  Must include the "FROM item"
     * @return a query leveraging the passed in arguments which will filter, order, page, and sort as appropriate.
     */
    private SearchQuery buildQuery(final SearchPermissions searchPermissions,
                                   final Optional<PageDto> maybePageDto,
                                   final Collection<Sort> sorts,
                                   final List<SearchFilter> searchFilters,
                                   Optional<Collection<SearchProperty>> maybeGroupBy,
                                   final String baseQuery) {
        StringBuilder sb = new StringBuilder(baseQuery);
        Set<String> tables = new HashSet<>();
        MapSqlParameterSource sqlParameterSource = new MapSqlParameterSource();

        List<SearchFilter> localSearchFilters = new ArrayList<>(searchFilters);

        Optional<KeywordSearchFilter> keywordSearchFilter = removeKeywordSearchFilter(localSearchFilters);
        if (keywordSearchFilter.isPresent()) {
            sb.append(keywordSearchFilter.get().getJoinClause());
        } else {
            sb.append(KeywordSearchFilter.getPlaceholderJoinClause());
        }

        if (!localSearchFilters.isEmpty()) {
            sb.append("  WHERE \n ");
            boolean first = true;

            for (SearchFilter filter : localSearchFilters) {
                Optional<FilterQuery> maybeFilterQuery = filter.getFilterQuery(searchPermissions);

                if (!maybeFilterQuery.isPresent()) {
                    continue;
                }

                FilterQuery filterQuery = maybeFilterQuery.get();
                tables.add(filter.getFilterProperty().getTable());

                if (!first) {
                    sb.append(" AND ");
                }

                sb.append(" (").append(filterQuery.getQuery()).append(") \n ");
                sqlParameterSource.addValues(filterQuery.getMapSqlProperties());
                first = false;
            }
        }

        //maybeGroupBy.ifPresent(searchProperty -> sb.append(" GROUP BY ").append(searchProperty.getColumnName()).append(" "));
        if (maybeGroupBy.isPresent()) {
            sb.append(" GROUP BY ");
            sb.append(maybeGroupBy.get().stream()
                .map(SearchProperty::getColumnName)
                .collect(Collectors.joining(", ")));
        }

        if (!sorts.isEmpty()) {
            sb.append(" ORDER BY ");
            Iterator<Sort> iter = sorts.iterator();
            while (iter.hasNext()) {
                Sort sort = iter.next();
                if (Sort.Direction.ITEM_ID_ORDER.equals(sort.getDirection())) {
                    sb.append(buildCaseSortAndUpdateParams(searchFilters, sqlParameterSource));
                } else {
                    sb.append(sort.getSearchProperty().getSortColumn()).append(" ")
                        .append(sort.getDirection().equals(Sort.Direction.ASC) ? " ASC " : " DESC ");
                }

                if (iter.hasNext()) {
                    sb.append(" , ");
                }
            }
        }

        if (maybePageDto.isPresent()) {
            PageDto pageDto = maybePageDto.get();
            int pageSize = pageDto.getPageSize() == null ? MAX_PAGE_SIZE : pageDto.getPageSize();
            int pageNumber = pageDto.getPageNumber() == null ? 0 : pageDto.getPageNumber();

            sb.append(" LIMIT ").append(pageSize).append(" OFFSET ").append(pageNumber * pageSize);
        }

        return new SearchQuery(sb.toString(), tables, sqlParameterSource);
    }

    private Optional<KeywordSearchFilter> removeKeywordSearchFilter(List<SearchFilter> searchFilters) {
        for (SearchFilter filter : searchFilters) {
            if (filter instanceof KeywordSearchFilter) {
                searchFilters.remove(filter);
                return Optional.of((KeywordSearchFilter) filter);
            }
        }
        return Optional.empty();
    }

    private String buildCaseSortAndUpdateParams(List<SearchFilter> searchFilters, MapSqlParameterSource params) {
        List<Integer> values = searchFilters.stream()
            .filter(searchFilter -> SearchProperty.ITEM_ID.equals(searchFilter.getFilterProperty()))
            .map(searchFilter -> ((IdMatchSearchFilter) searchFilter).getIdFilterValues())
            .findAny()
            .orElseThrow(
                () -> new IllegalArgumentException("Item id specific sorting requires a corresponding item id filter"));

        StringBuilder sb = new StringBuilder(" CASE " + SearchProperty.ITEM_ID.getColumnName() + " \n");
        int i = 1;
        for (Integer id : values) {
            String paramName = "itemOrder" + i;
            sb.append(" WHEN ").append(":").append(paramName).append(" THEN ").append(i).append("\n");
            params.addValue(paramName, id);
            i++;
        }
        sb.append(" END ");

        return sb.toString();
    }
}
