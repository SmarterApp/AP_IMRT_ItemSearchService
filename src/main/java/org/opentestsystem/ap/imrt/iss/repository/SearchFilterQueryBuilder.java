package org.opentestsystem.ap.imrt.iss.repository;

import org.opentestsystem.ap.imrt.iss.dto.search.PageDto;
import org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty;
import org.opentestsystem.ap.imrt.iss.dto.search.Sort;
import org.opentestsystem.ap.imrt.iss.model.FilterQuery;
import org.opentestsystem.ap.imrt.iss.model.SearchFilter;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Optional;
import java.util.Set;

/**
 * Handles building queries for general search
 */
@Component
public class SearchFilterQueryBuilder {
    private static final Integer MAX_PAGE_SIZE = 1000;

    /**
     * Builds the WHERE query for general search
     *
     * @param maybePageDto  the {@link PageDto} with the page information
     * @param sorts         the {@link Sort} to apply to the results
     * @param searchFilters the {@link SearchFilter} which are used to filter the results
     * @param baseQuery     the base query for the select.  Must include the "FROM item"
     * @return a query leveraging the passed in arguments which will filter, order, page, and sort as appropriate.
     */
    SearchQuery buildQuery(final Optional<PageDto> maybePageDto, final Collection<Sort> sorts, final List<SearchFilter> searchFilters, final String baseQuery) {
        return buildQuery(maybePageDto, sorts, searchFilters, Optional.empty(), baseQuery);
    }

    /**
     * Builds the WHERE query for general search
     *
     * @param searchFilters the {@link SearchFilter} which are used to filter the results
     * @param baseQuery     the base query for the select.  Must include the "FROM item"
     * @return a query leveraging the passed in arguments which will filter results
     */
    SearchQuery buildQuery(final List<SearchFilter> searchFilters, final String baseQuery) {
        return buildQuery(Optional.empty(), Collections.emptyList(), searchFilters, Optional.empty(), baseQuery);
    }

    /**
     * Builds the WHERE query for general search counts
     *
     * @param searchFilters the {@link SearchFilter} which are used to filter the results
     * @param groupBy       the {@link SearchProperty} to group results for counts
     * @param baseQuery     the base query for the select.  Must include the "FROM item"
     * @return a query leveraging the passed in arguments which will filter, order, page, and sort as appropriate.
     */
    SearchQuery buildQuery(final List<SearchFilter> searchFilters, SearchProperty groupBy, final String baseQuery) {
        return buildQuery(Optional.empty(), Collections.emptyList(), searchFilters, Optional.of(groupBy), baseQuery);
    }

    /**
     * Builds the WHERE query for general search
     *
     * @param maybePageDto  the {@link PageDto} with the page information
     * @param sorts         the {@link Sort} to apply to the results
     * @param searchFilters the {@link SearchFilter} which are used to filter the results
     * @param maybeGroupBy  the {@link SearchProperty} to group results for counts
     * @param baseQuery     the base query for the select.  Must include the "FROM item"
     * @return a query leveraging the passed in arguments which will filter, order, page, and sort as appropriate.
     */
    private SearchQuery buildQuery(final Optional<PageDto> maybePageDto, final Collection<Sort> sorts, final List<SearchFilter> searchFilters, Optional<SearchProperty> maybeGroupBy, final String baseQuery) {
        StringBuilder sb = new StringBuilder(baseQuery);
        Set<String> tables = new HashSet<>();
        MapSqlParameterSource sqlParameterSource = new MapSqlParameterSource();

        if (!searchFilters.isEmpty()) {
            sb.append(" WHERE \n ");
            boolean first = true;
            for (SearchFilter filter : searchFilters) {
                Optional<FilterQuery> maybeFilterQuery = filter.getFilterQuery();

                if(!maybeFilterQuery.isPresent()) {
                    continue;
                }

                FilterQuery filterQuery = maybeFilterQuery.get();
                tables.add(filter.getFilterProperty().getTable());

                if (!first) {
                    sb.append(" AND ");
                }

                sb.append(" (").append(filterQuery.getQuery()).append(") \n ");
                sqlParameterSource.addValues(filterQuery.getMapSqlProperties());
                first = false;
            }
        }

        maybeGroupBy.ifPresent(searchProperty -> sb.append(" GROUP BY ").append(searchProperty.getColumnName()).append(" "));

        if (!sorts.isEmpty()) {
            sb.append(" ORDER BY ");
            Iterator<Sort> iter = sorts.iterator();
            while (iter.hasNext()) {
                Sort sort = iter.next();
                sb.append(sort.getSearchProperty().getColumnName()).append(" ").append(sort.getDirection().equals(Sort.Direction.ASC) ? " ASC " : " DESC ");

                if (iter.hasNext()) {
                    sb.append(" , ");
                }
            }
        }

        if (maybePageDto.isPresent()) {
            PageDto pageDto = maybePageDto.get();
            int pageSize = pageDto.getPageSize() == null ? MAX_PAGE_SIZE : pageDto.getPageSize();
            int pageNumber = pageDto.getPageNumber() == null ? 0 : pageDto.getPageNumber();

            sb.append(" LIMIT ").append(pageSize).append(" OFFSET ").append(pageNumber * pageSize);
        }

        return new SearchQuery(sb.toString(), tables, sqlParameterSource);
    }
}
