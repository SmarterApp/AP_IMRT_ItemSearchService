package org.opentestsystem.ap.imrt.iss.service;

import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.opentestsystem.ap.common.security.SecurityUtil;
import org.opentestsystem.ap.imrt.iss.core.mapper.PermissionsMapper;
import org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty;
import org.opentestsystem.ap.imrt.iss.model.SearchFilter;
import org.opentestsystem.ap.imrt.iss.model.SearchPermissions;
import org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReport;
import org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReportBuilder;
import org.opentestsystem.ap.imrt.iss.repository.GapReportRepository;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
public class GapReportServiceImpl implements GapReportService {
    private final GapReportRepository gapReportRepository;
    private final GapReportBuilder gapReportBuilder;
    private final SecurityUtil securityUtil;
    private final PermissionsMapper permissionsMapper;

    public GapReportServiceImpl(final GapReportRepository gapReportRepository,
                                final GapReportBuilder gapReportBuilder,
                                SecurityUtil securityUtil,
                                PermissionsMapper permissionsMapper) {
        this.gapReportRepository = gapReportRepository;
        this.gapReportBuilder = gapReportBuilder;
        this.securityUtil = securityUtil;
        this.permissionsMapper = permissionsMapper;
    }

    @Override
    public Optional<File> getGapReport(final Collection<SearchFilter> searchFilters,
                                       final Collection<SearchProperty> groups) {
        final SearchPermissions searchPermissions = permissionsMapper.transform(securityUtil.getAuthenticatedUser());

        if (containsInvalidFilters(searchFilters) || doesNotHaveSearchPermissions(searchPermissions)) {
            return Optional.empty();
        }

        final List<String> invalidGroupProperties = groups.stream()
                .filter(g -> !g.isSupportsCounts())
                .map(SearchProperty::getProperty)
                .collect(Collectors.toList());

        if (!invalidGroupProperties.isEmpty()) {
            throw new IllegalArgumentException("The following group(s) are not supported: " + String.join(", ", invalidGroupProperties));
        }

        final List<Map<String, Object>> results = gapReportRepository.getGapReport(searchPermissions, searchFilters, groups);

        final XSSFWorkbook workbook = gapReportBuilder.convertToReport(new GapReport(searchFilters,
                groups,
                results,
                Instant.now()));

        try {
            final Path path = Files.createTempDirectory(UUID.randomUUID().toString());
            final DateFormat df = new SimpleDateFormat("yyyyMMddhhmmss");
            final File excelFile = new File(path.toFile(), "gap-report-" + df.format(new Date()) + ".xlsx");

            try (final FileOutputStream fso = new FileOutputStream(excelFile)) {
                workbook.write(fso);
            }

            return Optional.of(excelFile);
        } catch (final IOException e) {
            throw new RuntimeException("Unhandled exception while creating Gap Report excel file", e);
        }
    }

    /**
     * Determine if any of the {@link org.opentestsystem.ap.imrt.iss.model.SearchFilter}s contain invalid values.
     *
     * @param filters The collection of {@link org.opentestsystem.ap.imrt.iss.model.SearchFilter}s to evaluate
     * @return True if any of the {@link org.opentestsystem.ap.imrt.iss.model.SearchFilter}s are invalid; otherwise
     * false
     */
    private boolean containsInvalidFilters(Collection<SearchFilter> filters) {
        return filters.stream().anyMatch(searchFilter -> !searchFilter.containsValidFilterValues());
    }

    private boolean doesNotHaveSearchPermissions(final SearchPermissions searchPermissions) {
        return !searchPermissions.getPreviewAll().isPresent()
            && !searchPermissions.getPreviewVersion().isPresent()
            && !searchPermissions.getItemTypeToWorkflows().isEmpty()
            && !searchPermissions.getItemTypeToAssigneeWorkflows().isEmpty();
    }
}
