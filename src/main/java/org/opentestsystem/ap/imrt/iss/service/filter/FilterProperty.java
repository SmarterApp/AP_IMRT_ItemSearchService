package org.opentestsystem.ap.imrt.iss.service.filter;

import org.opentestsystem.ap.imrt.iss.dto.search.BooleanFlagFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.ContainsFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.DateRangeFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.Filter;
import org.opentestsystem.ap.imrt.iss.dto.search.MatchFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.NumberOfDaysRangeFilter;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.BEING_CREATED;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.CONTENT_TASK_MODEL;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.DAYS_IN_WORKFLOW_STATUS;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.DOK;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.GRADE;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.ITEM_AUTHOR;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.ITEM_ID;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.ITEM_TYPE;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.ORG_NAME;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.ORG_TYPE_ID;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.PRIMARY_CLAIM;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.PRIMARY_TARGET;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.STIMULUS_ID;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.SUBJECT;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.WORKFLOW_STATUS;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.WORKFLOW_STATUS_UPDATE_DATE;

/**
 * Utility class for filter processing.  Since callers can use whatever values they want for searches we need to ensure
 * IMRT knows which fields are supported by the system.
 */
public class FilterProperty {
    private static final Map<String, FilterConfiguration> FILTER_TO_FIElDS;

    static {
        Map<String, FilterConfiguration> filterToFields = new HashMap<>();
        filterToFields.put(ITEM_ID, new FilterConfiguration("id", MatchFilter.class));
        filterToFields.put(GRADE, new FilterConfiguration("grade", MatchFilter.class));
        filterToFields.put(STIMULUS_ID, new FilterConfiguration("associatedStimulusId", MatchFilter.class));
        filterToFields.put(DOK, new FilterConfiguration("depthOfKnowledge", MatchFilter.class));
        filterToFields.put(WORKFLOW_STATUS, new FilterConfiguration("workflowStatus", MatchFilter.class));
        filterToFields.put(ITEM_TYPE, new FilterConfiguration("itemType", MatchFilter.class));
        filterToFields.put(SUBJECT, new FilterConfiguration("subject", MatchFilter.class));
        filterToFields.put(DAYS_IN_WORKFLOW_STATUS, new FilterConfiguration("workflowStatusSetAt", NumberOfDaysRangeFilter.class));
        filterToFields.put(BEING_CREATED, new FilterConfiguration("beingCreated", BooleanFlagFilter.class));
        filterToFields.put(ORG_TYPE_ID, new FilterConfiguration("organizationTypeId", MatchFilter.class));
        filterToFields.put(ORG_NAME, new FilterConfiguration("organizationName", ContainsFilter.class));
        filterToFields.put(PRIMARY_CLAIM, new FilterConfiguration("primaryClaim", MatchFilter.class));
        filterToFields.put(PRIMARY_TARGET, new FilterConfiguration("primaryTarget", MatchFilter.class));
        filterToFields.put(CONTENT_TASK_MODEL, new FilterConfiguration("contentTaskModel", MatchFilter.class));
        filterToFields.put(ITEM_AUTHOR, new FilterConfiguration("itemAuthor", ContainsFilter.class));
        filterToFields.put(WORKFLOW_STATUS_UPDATE_DATE, new FilterConfiguration("workflowStatusSetAt", DateRangeFilter.class));

        FILTER_TO_FIElDS = Collections.unmodifiableMap(filterToFields);
    }

    /**
     * Check if the property sent by the client is searchable
     *
     * @param property the property to check
     * @return {@code true} if the property is valid
     */
    public static boolean isPropertySearchable(final String property) {
        return FILTER_TO_FIElDS.containsKey(property);
    }

    /**
     * Whether the filter type is supported by the filter
     *
     * @param filter the {@link Filter}
     * @return {@code true} if the property can be searched with that filter
     */
    public static boolean isSupportedFilterForProperty(final Filter filter) {
        return isPropertySearchable(filter.getProperty()) && FILTER_TO_FIElDS.get(filter.getProperty()).type.isInstance(filter);
    }

    /**
     * Normally the imrt property and the searchable property will align.  However, there are times where we name
     * things in IMRT differently than the item dictionary.  This handles the mapping.
     *
     * @param property the request filter property
     * @return the query property to use
     */
    public static Optional<String> getImrtSearchProperty(final String property) {
        return isPropertySearchable(property) ?
                Optional.of(FILTER_TO_FIElDS.get(property).imrtProperty) :
                Optional.empty();
    }

    private static class FilterConfiguration {
        private final String imrtProperty;
        private final Class<? extends Filter> type;

        FilterConfiguration(final String imrtProperty, final Class<? extends Filter> type) {
            this.imrtProperty = imrtProperty;
            this.type = type;
        }
    }
}
