package org.opentestsystem.ap.imrt.iss.service.filter;

import org.opentestsystem.ap.imrt.iss.dto.search.Filter;
import org.opentestsystem.ap.imrt.iss.dto.search.MatchFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.NumberOfDaysRangeFilter;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

/**
 * Utility class for filter processing.  Since callers can use whatever values they want for searches we need to ensure
 * IMRT knows which fields are supported by the system.
 */
public class FilterProperty {
    private static final Map<String, FilterConfiguration> FILTER_TO_FIElDS;

    static {
        Map<String, FilterConfiguration> filterToFields = new HashMap<>();
        filterToFields.put("itemId", new FilterConfiguration("id", MatchFilter.class));
        filterToFields.put("grade", new FilterConfiguration("grade", MatchFilter.class));
        filterToFields.put("stimulusId", new FilterConfiguration("associatedStimulusId", MatchFilter.class));
        filterToFields.put("depthOfKnowledge", new FilterConfiguration("depthOfKnowledge", MatchFilter.class));
        filterToFields.put("workflowStatus", new FilterConfiguration("workflowStatus", MatchFilter.class));
        filterToFields.put("itemType", new FilterConfiguration("itemType", MatchFilter.class));
        filterToFields.put("subject", new FilterConfiguration("subject", MatchFilter.class));
        filterToFields.put("workflowStatusSetAt", new FilterConfiguration("workflowStatusSetAt", NumberOfDaysRangeFilter.class));

        FILTER_TO_FIElDS = Collections.unmodifiableMap(filterToFields);
    }

    /**
     * Check if the property sent by the client is searchable
     *
     * @param property the property to check
     * @return {@code true} if the property is valid
     */
    public static boolean isPropertySearchable(final String property) {
        return FILTER_TO_FIElDS.containsKey(property);
    }

    /**
     * Whether the filter type is supported by the filter
     *
     * @param filter the {@link Filter}
     * @return {@code true} if the property can be searched with that filter
     */
    public static boolean isSupportedFilterForProperty(final Filter filter) {
        return isPropertySearchable(filter.getProperty()) && FILTER_TO_FIElDS.get(filter.getProperty()).type.isInstance(filter);
    }

    /**
     * Normally the imrt property and the searchable property will align.  However, there are times where we name
     * things in IMRT differently than the item dictionary.  This handles the mapping.
     *
     * @param property the request filter property
     * @return the query property to use
     */
    public static Optional<String> getImrtSearchProperty(final String property) {
        return isPropertySearchable(property) ?
                Optional.of(FILTER_TO_FIElDS.get(property).imrtProperty) :
                Optional.empty();
    }

    private static class FilterConfiguration {
        private final String imrtProperty;
        private final Class<? extends Filter> type;

        FilterConfiguration(final String imrtProperty, final Class<? extends Filter> type) {
            this.imrtProperty = imrtProperty;
            this.type = type;
        }
    }
}
