package org.opentestsystem.ap.imrt.iss.core.keyword;

import com.fathzer.soft.javaluator.AbstractEvaluator;
import com.fathzer.soft.javaluator.BracketPair;
import com.fathzer.soft.javaluator.Operator;
import com.fathzer.soft.javaluator.Parameters;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static org.apache.commons.lang3.StringUtils.isBlank;

public abstract class KeywordSearchToRegexEvaluator<T> extends AbstractEvaluator<T> {
    static final String AND_SYMBOL = "&&";
    static final String OR_SYMBOL = "||";
    static final String NEGATE_SYMBOL = "~";
    static final char MULTI_WILDCARD = '*';
    static final char SINGLE_WILDCARD = '_';

    private final static Operator AND = new Operator(AND_SYMBOL, 2, Operator.Associativity.LEFT, 2);
    private final static Operator OR = new Operator(OR_SYMBOL, 2, Operator.Associativity.LEFT, 1);
    private final static Operator NEGATE = new Operator(NEGATE_SYMBOL, 1, Operator.Associativity.RIGHT, 3);

    private static final String ERROR_MESSAGE_PREFIX = "Keyword search error: ";
    private static final String ESCAPED_DOUBLE_QUOTE = "\uF0000";
    private static final String QUOTE_MARKER = "\":";
    private static final String REGEX_SPECIAL_CHARS = "[.+?*^${}()|[]\\";

    private static final Pattern UUID_PATTERN =
            Pattern.compile("[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}");

    private static final Parameters PARAMETERS;

    static {
        PARAMETERS = new Parameters();
        PARAMETERS.add(AND);
        PARAMETERS.add(OR);
        PARAMETERS.add(NEGATE);
        PARAMETERS.addExpressionBracket(BracketPair.BRACES);
    }

    private final Map<String, String> substitutions = new HashMap<>();

    public KeywordSearchToRegexEvaluator() {
        super(PARAMETERS);
    }

    /**
     * Implemented by subclasses to convert a regex token from the search string into
     * a value of whatever type is relevant to the subclass.
     *
     * @param regexToken a regex expression translated from the original search string.
     * @return a value for the expression based on the needs of the subclass.
     */
    abstract protected T convertRegexToken(String regexToken);

    @Override
    protected T toValue(String token, Object evaluationContext) {
        token = (token == null) ? "" : token;
        Matcher matcher = UUID_PATTERN.matcher(token);
        boolean isQuote = false;

        while (matcher.find()) {
            isQuote = true;
            String uuid = matcher.group();
            if (substitutions.containsKey(uuid)) {
                token = token.replace(uuid, substitutions.get(uuid));
            }
        }

        if (isQuote) {
            token = QUOTE_MARKER + token;
        }

        return convertRegexToken(convertToRegex(token));
    }

    @Override
    public T evaluate(String expression, Object evaluationContext) {
        if (isBlank(expression)) {
            throw new IllegalArgumentException(ERROR_MESSAGE_PREFIX + "search string cannot be blank");
        }
        String editedString = extractQuotedStrings(expression, substitutions);

        try {
            return super.evaluate(editedString, null);
        } catch (IllegalArgumentException e) {
            if (isBlank(e.getMessage())) {
                String errorMessage =
                        String.format("cannot parse expression. Mismatched %s, %s, or %s.",
                                AND_SYMBOL, OR_SYMBOL, NEGATE_SYMBOL);

                throw new IllegalArgumentException(ERROR_MESSAGE_PREFIX + errorMessage, e);
            } else if (!e.getMessage().startsWith(ERROR_MESSAGE_PREFIX)) {
                throw new IllegalArgumentException(ERROR_MESSAGE_PREFIX + e.getMessage(), e);
            } else {
                throw(e);
            }
        }
    }

    protected boolean isAnd(Operator operator) {
        return operator == AND;
    }

    protected boolean isOr(Operator operator) {
        return operator == OR;
    }

    protected boolean isNegate(Operator operator) {
        return operator == NEGATE;
    }


    private String convertToRegex(String token) {
        boolean isQuoted = token.startsWith(QUOTE_MARKER);
        String editedToken = isQuoted ? token.substring(QUOTE_MARKER.length()) : token;
        editedToken = editedToken
                .replaceAll("\\s+", " ")
                .trim()
                .replaceAll(ESCAPED_DOUBLE_QUOTE, "\"");

        StringBuilder sb = new StringBuilder();

        char [] chars = editedToken.toCharArray();

        for (char c : chars) {
            if (c == SINGLE_WILDCARD && !isQuoted) {
                sb.append("\\S");
            } else if (c == MULTI_WILDCARD && !isQuoted) {
                sb.append("\\S*");
            } else if (REGEX_SPECIAL_CHARS.indexOf(c) >= 0) {
                sb.append("\\").append(c);
            } else {
                sb.append(c);
            }
        }

        return sb.toString();
    }

    private String extractQuotedStrings(String expression, Map<String,String> extractedStrings) {
        String cleanedExpression = expression
                .replaceAll("\"\"", ESCAPED_DOUBLE_QUOTE);
        StringBuilder editedSearchString = new StringBuilder();
        StringBuilder quoted = new StringBuilder();

        boolean inQuotes = false;

        for (char c : cleanedExpression.toCharArray()) {
            if (inQuotes) {
                if (c == '"') {
                    inQuotes = false;
                    String uuid = UUID.randomUUID().toString();

                    extractedStrings.put(uuid, quoted.toString());
                    editedSearchString.append(uuid);
                    quoted.setLength(0);
                } else {
                    quoted.append(c);
                }
            } else if (c == '"') {
                inQuotes = true;
            } else {
                editedSearchString.append(c);
            }
        }

        if (inQuotes) {
            throw new IllegalArgumentException(ERROR_MESSAGE_PREFIX + "mismatched quotes");
        }

        return editedSearchString.toString();
    }
}
