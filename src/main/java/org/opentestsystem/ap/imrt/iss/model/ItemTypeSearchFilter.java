package org.opentestsystem.ap.imrt.iss.model;

import com.google.common.collect.ImmutableList;
import org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

public class ItemTypeSearchFilter extends AbstractSearchFilter implements SearchFilter {
    private final List<String> filterValues;

    public ItemTypeSearchFilter(final SearchProperty filterProperty, final List<String> filterValues) {
        super(filterProperty);
        this.filterValues = filterValues;
    }

    public ItemTypeSearchFilter(final SearchProperty searchProperty,
                                final boolean includeBlanks,
                                final List<String> filterValues) {
        super(searchProperty, includeBlanks);
        this.filterValues = filterValues;
    }

    @Override
    public Optional<FilterQuery> getFilterQuery(final SearchPermissions searchPermissions) {
        if(filterValues.isEmpty()) {
           return createPermissionsBasedFilter(searchPermissions);
        }

        List<String> filterValues = new ArrayList<>(this.filterValues);

        final String query = getFilterProperty().getColumnName() + " IN (:" + getFilterProperty().getProperty() + ") ";

        Map<String, Object> parameters = new HashMap<>();
        parameters.put(getFilterProperty().getProperty(), filterValues);

        return Optional.of(new FilterQuery(query, parameters));
    }

    public List<String> getFilterValues() {
        return ImmutableList.copyOf(filterValues);
    }

    @Override
    public boolean isEmpty() {
        return getFilterValues().isEmpty() && !isIncludeBlanks();
    }

    private Optional<FilterQuery> createPermissionsBasedFilter(final SearchPermissions searchPermissions) {
        if (searchPermissions.getPreviewAll().isPresent() || searchPermissions.getPreviewVersion().isPresent()) {
            return Optional.empty();
        }

        Map<String, Object> parameters = new HashMap<>();

        StringBuilder sb = new StringBuilder("( ");
        boolean firstRecord = true;
        for (Map.Entry<String, Collection<String>> entry : searchPermissions.getItemTypeToWorkflows().entrySet()) {
            if (!firstRecord) {
                sb.append(" AND ");
            }

            firstRecord = false;

            final String itemTypeParameterName = getFilterProperty().getProperty() + entry.getKey();
            final String workflowParameterName = getFilterProperty().getProperty() + entry.getKey() + "Workflow";
            sb.append(getFilterProperty().getColumnName())
                .append(" = :").append(itemTypeParameterName).append(" AND ")
                .append(SearchProperty.WORKFLOW_STATUS.getColumnName())
                .append(" IN (:")
                .append(workflowParameterName)
                .append(")");

            parameters.put(itemTypeParameterName, entry.getKey());
            parameters.put(workflowParameterName, concatWorkflows(entry.getValue()));
        }

        sb.append(" ) ");
        return Optional.of(new FilterQuery(sb.toString(), parameters));
    }

    private String concatWorkflows(Collection<String> workflowStatuses) {
        return workflowStatuses.stream()
            .map(Object::toString)
            .collect(Collectors.joining(","));
    }
}
