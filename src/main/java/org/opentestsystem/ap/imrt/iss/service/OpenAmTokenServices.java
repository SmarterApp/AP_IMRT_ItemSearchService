package org.opentestsystem.ap.imrt.iss.service;

import org.opentestsystem.ap.imrt.iss.config.ResourceServerProperties;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.client.ClientHttpResponse;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.oauth2.common.OAuth2AccessToken;
import org.springframework.security.oauth2.common.exceptions.InvalidTokenException;
import org.springframework.security.oauth2.provider.OAuth2Authentication;
import org.springframework.security.oauth2.provider.token.DefaultAccessTokenConverter;
import org.springframework.security.oauth2.provider.token.ResourceServerTokenServices;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.DefaultResponseErrorHandler;
import org.springframework.web.client.RestOperations;
import org.springframework.web.client.RestTemplate;

import java.io.IOException;
import java.util.Map;

/**
 * Class to provide validation of OAuth2 tokens using an OpenAM Authorization server
 * Based on {@link org.springframework.security.oauth2.provider.token.RemoteTokenServices}
 * but modified to communicate with an OpenAM server
 */
public class OpenAmTokenServices implements ResourceServerTokenServices {
    private static final Logger logger = LoggerFactory.getLogger(OpenAmTokenServices.class);

    private final RestOperations restTemplate;
    private final DefaultAccessTokenConverter tokenConverter;
    private final ResourceServerProperties properties;

    public OpenAmTokenServices(ResourceServerProperties properties) {
        this.properties = properties;
        restTemplate = new RestTemplate();
        ((RestTemplate) restTemplate).setErrorHandler(new DefaultResponseErrorHandler() {
            @Override
            // Ignore 400, that is what is returned if the token is invalid
            // Better to pass back the json body to make the error message available
            public void handleError(ClientHttpResponse response) throws IOException {
                if (response.getRawStatusCode() != 400) {
                    super.handleError(response);
                }
            }
        });
        tokenConverter = new DefaultAccessTokenConverter();
        tokenConverter.setIncludeGrantType(true);
    }

    @Override
    public OAuth2Authentication loadAuthentication(String accessToken) throws AuthenticationException, InvalidTokenException {
        logger.debug("loadAuthentication token {} url {}", accessToken, properties.getCheckTokenEndpointUrl());
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "Bearer " + accessToken);
        Map map = restTemplate.exchange(properties.getCheckTokenEndpointUrl(), HttpMethod.GET,
                new HttpEntity<MultiValueMap<String, String>>(null, headers), Map.class).getBody();

        logger.debug("authorization result {}", map);

        if (map.containsKey("error")) {
            logger.debug("check_token returned error: " + map.get("error"));
            throw new InvalidTokenException(accessToken);
        }

        @SuppressWarnings("unchecked")
        OAuth2Authentication result = tokenConverter.extractAuthentication(map);
        logger.debug("Result {} grant type {} scope {}", result, result.getOAuth2Request().getGrantType(), result.getOAuth2Request().getScope());
        return result;
    }

    @Override
    public OAuth2AccessToken readAccessToken(String accessToken) {
        throw new UnsupportedOperationException("Not supported: read access token");
    }
}
