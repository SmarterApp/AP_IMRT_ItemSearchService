package org.opentestsystem.ap.imrt.iss.service;

import org.opentestsystem.ap.imrt.common.model.BaseItem;
import org.opentestsystem.ap.imrt.common.service.OperationalEventService;
import org.opentestsystem.ap.imrt.iss.config.ItemSearchServiceProperties;
import org.opentestsystem.ap.imrt.iss.dto.search.Filter;
import org.opentestsystem.ap.imrt.iss.dto.search.SearchRequest;
import org.opentestsystem.ap.imrt.iss.repository.BaseItemSearchRepository;
import org.opentestsystem.ap.imrt.iss.service.filter.FilterProcessor;
import org.opentestsystem.ap.imrt.iss.service.filter.FilterProperty;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.data.jpa.domain.Specifications;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import static org.opentestsystem.ap.imrt.iss.dto.search.Sort.Direction.ASC;

@Service
public class ItemSearchServiceImpl implements ItemSearchService {
    private static final Logger LOG = LoggerFactory.getLogger(ItemSearchServiceImpl.class);

    private final BaseItemSearchRepository baseItemSearchRepository;
    private final FilterProcessor<BaseItem> filterProcessor;
    private final ItemSearchServiceProperties itemSearchServiceProperties;
    private final OperationalEventService logger;

    public ItemSearchServiceImpl(final OperationalEventService logger,
                                 final BaseItemSearchRepository baseItemSearchRepository,
                                 final FilterProcessor<BaseItem> filterProcessor,
                                 final ItemSearchServiceProperties itemSearchServiceProperties) {
        this.baseItemSearchRepository = baseItemSearchRepository;
        this.filterProcessor = filterProcessor;
        this.logger = logger;
        this.itemSearchServiceProperties = itemSearchServiceProperties;
    }

    @Override
    public Page<BaseItem> searchItems(final SearchRequest searchRequest) {
        Optional<Specifications<BaseItem>> maybeSpecifications = createSpecification(searchRequest);

        //If there are no filters or if the filters sent are not supported there will not be any specifications to run.
        if (maybeSpecifications.isPresent()) {
            return baseItemSearchRepository.findAll(maybeSpecifications.get(), mapPageAndSort(searchRequest));
        }

        //Finds all items sorted in the order as requested by caller
        return baseItemSearchRepository.findAll(mapPageAndSort(searchRequest));
    }

    private Optional<Specifications<BaseItem>> createSpecification(final SearchRequest searchCriteria) {
        List<Specification<BaseItem>> specifications = new ArrayList<>();

        for (Filter filter : searchCriteria.getFilters()) {
            Optional<Specification<BaseItem>> maybeSpec = filterProcessor.processFilter(filter);

            if (maybeSpec.isPresent()) {
                specifications.add(maybeSpec.get());
            } else {
                logger.serviceWarning(LOG, null, "Could not map specification for filter type {} and property {}", filter.getType(), filter.getProperty());
            }
        }

        //If there are no filters or if the filters sent are not supported there will not be any specifications to run.
        if (specifications.isEmpty()) {
            return Optional.empty();
        }

        //For the first phase of IMRT we "AND" all filters.
        Specifications<BaseItem> spec = null;
        for (Specification<BaseItem> specification : specifications) {
            if (spec == null) {
                spec = Specifications.where(specification);
                continue;
            }

            spec = spec.and(specification);
        }

        return Optional.of(spec);
    }

    /**
     * Maps page and sort handling null values
     *
     * @param searchRequest {@link SearchRequest} sent by client
     * @return the {@link PageRequest} object used by JPA for paging
     */
    private PageRequest mapPageAndSort(SearchRequest searchRequest) {
        final Optional<Sort> maybeSort = mapSort(searchRequest.getSort());

        if(searchRequest.getPage().isPresent() && searchRequest.getPage().get().getNumber() <= 0) {
            throw new IllegalArgumentException("Page number must be greater than zero");
        }

        return searchRequest.getPage()
                .map(pageRequest -> new PageRequest((pageRequest.getNumber() > 0 ? pageRequest.getNumber() - 1 : 0),
                        pageRequest.getSize(),
                        maybeSort.orElse(null)))
                .orElse(new PageRequest(0, itemSearchServiceProperties.getMaxSearchResults(), maybeSort.orElse(null)));
    }

    private Optional<Sort> mapSort(Optional<org.opentestsystem.ap.imrt.iss.dto.search.Sort> maybeSort) {
        if (!maybeSort.isPresent()) {
            return Optional.empty();
        }

        Optional<String> maybeImrtItemProperty = FilterProperty.getImrtSearchProperty(maybeSort.get().getProperty());
        if (!maybeImrtItemProperty.isPresent()) {
            return Optional.empty();
        }

        if(maybeSort.get().getDirection() == null) {
            throw new IllegalArgumentException("Sort requires a \"direction\" value of ASC or DESC");
        }

        Sort.Direction direction = ASC == maybeSort.get().getDirection() ? Sort.Direction.ASC : Sort.Direction.DESC;
        return Optional.of(new Sort(direction, maybeImrtItemProperty.get()));
    }
}
