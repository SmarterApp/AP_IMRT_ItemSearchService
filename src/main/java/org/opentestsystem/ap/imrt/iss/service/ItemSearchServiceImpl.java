package org.opentestsystem.ap.imrt.iss.service;

import org.opentestsystem.ap.imrt.iss.config.ItemSearchServiceProperties;
import org.opentestsystem.ap.imrt.iss.dto.ItemDto;
import org.opentestsystem.ap.imrt.iss.dto.SearchResults;
import org.opentestsystem.ap.imrt.iss.dto.search.PageDto;
import org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty;
import org.opentestsystem.ap.imrt.iss.dto.search.Sort;
import org.opentestsystem.ap.imrt.iss.model.SearchFilter;
import org.opentestsystem.ap.imrt.iss.repository.GeneralSearchRepository;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.DAYS_IN_WORKFLOW_STATUS;
import static org.opentestsystem.ap.imrt.iss.dto.search.Sort.Direction.ASC;

@Service
public class ItemSearchServiceImpl implements ItemSearchService {
    private final GeneralSearchRepository generalSearchRepository;
    private final ItemSearchServiceProperties itemSearchServiceProperties;

    public ItemSearchServiceImpl(final GeneralSearchRepository generalSearchRepository, final ItemSearchServiceProperties itemSearchServiceProperties) {
        this.generalSearchRepository = generalSearchRepository;
        this.itemSearchServiceProperties = itemSearchServiceProperties;
    }

    @Override
    public SearchResults<ItemDto> searchItems(final List<SearchFilter> filters, final Sort sort, final PageDto pageDto) {
        validatePage(pageDto);
        if (isFiltersInvalid(filters)) {
            return new SearchResults<>(Collections.emptyList(), 0, pageDto);
        }

        int totalCount = generalSearchRepository.getTotalItemsCount(filters);

        if (totalCount == 0) {
            return new SearchResults<>(Collections.emptyList(), 0, pageDto);
        }

        List<ItemDto> slice = generalSearchRepository.findSlice(pageDto, Collections.singletonList(handleDaysInWorkflowStatus(sort)), filters);

        return new SearchResults<>(slice, totalCount, pageDto);
    }

    @Override
    public Optional<Map<String, Long>> getCounts(final List<SearchFilter> filters, final SearchProperty groupBy) {
        if (isFiltersInvalid(filters)) {
            return Optional.empty();
        }

        return Optional.of(generalSearchRepository.getGroupCounts(groupBy, filters));
    }

    private void validatePage(PageDto pageDto) {
        if (pageDto.getPageNumber() < 0) {
            throw new IllegalArgumentException("Page number must be greater than or equal zero");
        }

        if (pageDto.getPageSize() > itemSearchServiceProperties.getMaxSearchResults() || pageDto.getPageSize() < 1) {
            throw new IllegalArgumentException("Number of results for a single page must be between 1 to 1000");
        }
    }

    //TODO - Look if there is better way to handle this so it isn't so explicit.
    private Sort handleDaysInWorkflowStatus(Sort sort) {
        if (!sort.getSearchProperty().equals(DAYS_IN_WORKFLOW_STATUS)) {
            return sort;
        }

        /*
        Days in workflow status is a derived field at query time.  THe sorting needs to be flipped from the request
        so that asc sorts by the newest date to oldest and vice versa.
         */
        Sort.Direction direction = ASC == sort.getDirection() ? Sort.Direction.DESC : Sort.Direction.ASC;

        return new Sort(sort.getSearchProperty().getProperty(), direction);
    }

    private boolean isFiltersInvalid(List<SearchFilter> filters) throws IllegalArgumentException {
        for (SearchFilter filter : filters) {
            if (!filter.isValid()) {
                return true;
            }
        }

        return false;
    }
}
