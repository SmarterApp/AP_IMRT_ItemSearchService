package org.opentestsystem.ap.imrt.iss.service;

import org.opentestsystem.ap.imrt.common.model.BaseItem;
import org.opentestsystem.ap.imrt.iss.dto.search.CountRequest;
import org.opentestsystem.ap.imrt.iss.dto.search.SearchRequest;
import org.opentestsystem.ap.imrt.iss.repository.BaseItemSearchRepository;
import org.opentestsystem.ap.imrt.iss.repository.ItemSearchGroupAndCountRepository;
import org.opentestsystem.ap.imrt.iss.service.filter.FilterProcessor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.Specifications;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

import static org.opentestsystem.ap.imrt.iss.dto.search.Sort.Direction.ASC;
import static org.opentestsystem.ap.imrt.iss.service.filter.FilterProperty.getImrtSearchProperty;

@Service
public class ItemSearchServiceImpl implements ItemSearchService {
    private static final Map<String, String> COUNTS_TO_FIELDS;

    static {
        Map<String, String> countsToFields = new HashMap<>();
        countsToFields.put("itemId", "id");
        countsToFields.put("grade", "grade");
        countsToFields.put("workflowStatus", "workflowStatus");
        countsToFields.put("itemType", "itemType");
        countsToFields.put("subject", "subject");
        countsToFields.put("organizationTypeId", "organizationTypeId");
        countsToFields.put("organizationName", "organizationName");
        countsToFields.put("primaryClaim", "primaryClaim");
        countsToFields.put("primaryAssessmentTarget", "primaryTarget");

        COUNTS_TO_FIELDS = Collections.unmodifiableMap(countsToFields);
    }


    private final BaseItemSearchRepository baseItemSearchRepository;
    private final FilterProcessor<BaseItem> filterProcessor;
    private final ItemSearchGroupAndCountRepository itemSearchGroupAndCountRepository;

    public ItemSearchServiceImpl(final BaseItemSearchRepository baseItemSearchRepository,
                                 final FilterProcessor<BaseItem> filterProcessor,
                                 final ItemSearchGroupAndCountRepository itemSearchGroupAndCountRepository) {
        this.baseItemSearchRepository = baseItemSearchRepository;
        this.filterProcessor = filterProcessor;
        this.itemSearchGroupAndCountRepository = itemSearchGroupAndCountRepository;
    }

    @Override
    public Page<BaseItem> searchItems(final SearchRequest searchRequest) {
        Optional<Specifications<BaseItem>> maybeSpecifications = filterProcessor.processFilters(searchRequest.getFilters());

        //If there are no filters or if the filters sent are not supported there will not be any specifications to run.
        if (maybeSpecifications.isPresent()) {
            return baseItemSearchRepository.findAll(maybeSpecifications.get(), mapPageAndSort(searchRequest));
        }

        //Finds all items sorted in the order as requested by caller
        return baseItemSearchRepository.findAll(mapPageAndSort(searchRequest));
    }

    @Override
    public Map<String, Long> getCounts(final CountRequest countRequest) {
        if (!COUNTS_TO_FIELDS.containsKey(countRequest.getGroupBy())) {
            throw new IllegalArgumentException("Unsupported group by property.  Please check API documentation");
        }

        Optional<Specifications<BaseItem>> maybeSpecifications = filterProcessor.processFilters(countRequest.getFilters());

        final String groupBy = COUNTS_TO_FIELDS.get(countRequest.getGroupBy());

        if (maybeSpecifications.isPresent()) {
            return itemSearchGroupAndCountRepository.getGroupCounts(groupBy, maybeSpecifications.get());
        }

        return itemSearchGroupAndCountRepository.getGroupCounts(groupBy);
    }

    /**
     * Maps page and sort handling null values
     *
     * @param searchRequest {@link SearchRequest} sent by client
     * @return the {@link PageRequest} object used by JPA for paging
     */
    private PageRequest mapPageAndSort(SearchRequest searchRequest) {
        final Optional<Sort> maybeSort = mapSort(searchRequest.getSort());

        if (searchRequest.getPage().getPageNumber() < 0) {
            throw new IllegalArgumentException("Page number must be greater than or equal zero");
        }

        if (searchRequest.getPage().getPageSize() > 1000) {
            throw new IllegalArgumentException("Number of results for a single page cannot be greater than 1000");
        }

        return new PageRequest(searchRequest.getPage().getPageNumber(),
                searchRequest.getPage().getPageSize(),
                maybeSort.orElse(null));
    }

    private Optional<Sort> mapSort(org.opentestsystem.ap.imrt.iss.dto.search.Sort sort) {
        Optional<String> maybeImrtItemProperty = getImrtSearchProperty(sort.getProperty());
        if (!maybeImrtItemProperty.isPresent()) {
            return Optional.empty();
        }

        Sort.Direction direction = ASC == sort.getDirection() ? Sort.Direction.ASC : Sort.Direction.DESC;
        return Optional.of(new Sort(direction, maybeImrtItemProperty.get()));
    }
}
