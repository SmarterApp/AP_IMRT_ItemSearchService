package org.opentestsystem.ap.imrt.iss.service;

import org.opentestsystem.ap.imrt.iss.dto.ItemDto;
import org.opentestsystem.ap.imrt.iss.dto.SearchResults;
import org.opentestsystem.ap.imrt.iss.dto.search.PageDto;
import org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty;
import org.opentestsystem.ap.imrt.iss.dto.search.Sort;
import org.opentestsystem.ap.imrt.iss.model.SearchFilter;
import org.opentestsystem.ap.imrt.iss.model.SortQuery;
import org.opentestsystem.ap.imrt.iss.repository.GeneralSearchRepository;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.DAYS_IN_WORKFLOW_STATUS;
import static org.opentestsystem.ap.imrt.iss.dto.search.Sort.Direction.ASC;

@Service
public class ItemSearchServiceImpl implements ItemSearchService {
    private final GeneralSearchRepository generalSearchRepository;

    public ItemSearchServiceImpl(final GeneralSearchRepository generalSearchRepository) {
        this.generalSearchRepository = generalSearchRepository;
    }

    @Override
    public SearchResults<ItemDto> searchItems(final List<SearchFilter> filters, final Sort sort, final PageDto pageDto) {
        validatePage(pageDto);
        if (isFiltersInvalid(filters)) {
            return new SearchResults<>(Collections.emptyList(), 0, pageDto);
        }

        int totalCount = generalSearchRepository.getTotalItemsCount(filters);

        if (totalCount == 0) {
            return new SearchResults<>(Collections.emptyList(), 0, pageDto);
        }

        List<ItemDto> slice = generalSearchRepository.findSlice(pageDto, Collections.singletonList(mapSort(sort)), filters);

        return new SearchResults<>(slice, totalCount, pageDto);
    }

    @Override
    public Optional<Map<String, Long>> getCounts(final List<SearchFilter> filters, final SearchProperty groupBy) {
        if (isFiltersInvalid(filters)) {
            return Optional.empty();
        }

        return Optional.of(generalSearchRepository.getGroupCounts(groupBy, filters));
    }

    private void validatePage(PageDto pageDto) {
        if (pageDto.getPageNumber() < 0) {
            throw new IllegalArgumentException("Page number must be greater than or equal zero");
        }

        if (pageDto.getPageSize() > 1000) {
            throw new IllegalArgumentException("Number of results for a single page cannot be greater than 1000");
        }
    }

    private SortQuery mapSort(Sort sort) {
        Optional<SearchProperty> maybeImrtSortProperty = SearchProperty.propertyValueOf(sort.getProperty());
        if (!maybeImrtSortProperty.isPresent()) {
            throw new IllegalArgumentException("Unsupported sort property selected: " + sort.getProperty());
        }

        Sort.Direction direction;

        /*
        Days in workflow status is a derived field at query time.  THe sorting needs to be flipped from the request
        so that asc sorts by the newest date to oldest and vice versa.
         */
        //TODO - Look if there is better way to handle this so it isn't so explicit.
        if (DAYS_IN_WORKFLOW_STATUS.equals(sort.getProperty())) {
            direction = ASC == sort.getDirection() ? Sort.Direction.DESC : Sort.Direction.ASC;
        } else {
            direction = ASC == sort.getDirection() ? Sort.Direction.ASC : Sort.Direction.DESC;
        }

        return new SortQuery(maybeImrtSortProperty.get(), direction);
    }

    private boolean isFiltersInvalid(List<SearchFilter> filters) throws IllegalArgumentException {
        for (SearchFilter filter : filters) {
            if (!filter.isValid()) {
                return true;
            }
        }

        return false;
    }
}
