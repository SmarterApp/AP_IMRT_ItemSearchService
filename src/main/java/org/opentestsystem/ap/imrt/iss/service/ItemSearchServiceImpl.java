package org.opentestsystem.ap.imrt.iss.service;

import org.opentestsystem.ap.common.security.SecurityUtil;
import org.opentestsystem.ap.imrt.iss.config.ItemSearchServiceProperties;
import org.opentestsystem.ap.imrt.iss.core.mapper.PermissionsMapper;
import org.opentestsystem.ap.imrt.iss.dto.ItemSearchResult;
import org.opentestsystem.ap.imrt.iss.dto.SearchResults;
import org.opentestsystem.ap.imrt.iss.dto.search.PageDto;
import org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty;
import org.opentestsystem.ap.imrt.iss.dto.search.Sort;
import org.opentestsystem.ap.imrt.iss.model.IdMatchSearchFilter;
import org.opentestsystem.ap.imrt.iss.model.PermissionsBasedSearchFilter;
import org.opentestsystem.ap.imrt.iss.model.SearchFilter;
import org.opentestsystem.ap.imrt.iss.model.SearchPermissions;
import org.opentestsystem.ap.imrt.iss.repository.GeneralSearchRepository;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.DAYS_IN_WORKFLOW_STATUS;
import static org.opentestsystem.ap.imrt.iss.dto.search.Sort.Direction.ASC;
import static org.opentestsystem.ap.imrt.iss.dto.search.Sort.Direction.ITEM_ID_ORDER;

@Service
public class ItemSearchServiceImpl implements ItemSearchService {
    private final GeneralSearchRepository generalSearchRepository;
    private final ItemSearchServiceProperties itemSearchServiceProperties;
    private final SecurityUtil securityUtil;
    private final PermissionsMapper permissionsMapper;

    public ItemSearchServiceImpl(final GeneralSearchRepository generalSearchRepository,
                                 final ItemSearchServiceProperties itemSearchServiceProperties,
                                 final SecurityUtil securityUtil,
                                 final PermissionsMapper permissionsMapper) {
        this.generalSearchRepository = generalSearchRepository;
        this.itemSearchServiceProperties = itemSearchServiceProperties;
        this.securityUtil = securityUtil;
        this.permissionsMapper = permissionsMapper;
    }

    @Override
    public SearchResults<ItemSearchResult> searchItems(final List<SearchFilter> requestFilters,
                                                       final Sort sort,
                                                       final PageDto pageDto) {
        validatePage(pageDto);

        SearchPermissions searchPermissions = permissionsMapper
            .transform(securityUtil.getItemBankUser().getAuthenticatedUser());

        List<SearchFilter> filters = new ArrayList<>(requestFilters);
        filters.add(new PermissionsBasedSearchFilter());

        //Item ID order sort has specific rules
        if (ITEM_ID_ORDER.equals(sort.getDirection())) {
            if (!SearchProperty.ITEM_ID.equals(sort.getSearchProperty())) {
                throw new IllegalArgumentException(
                    "itemIdSort sort direction requires the sort property to be " + SearchProperty.ITEM_ID
                        .getProperty());
            }

            //This needs to downcast because TIMS sends the item id filter each time regardless if it needs to be filtered
            filters.stream()
                .filter(searchFilter -> SearchProperty.ITEM_ID.equals(searchFilter.getFilterProperty()))
                .filter(searchFilter -> !((IdMatchSearchFilter) searchFilter).getIdFilterValues().isEmpty())
                .findAny()
                .orElseThrow(() -> new IllegalArgumentException(
                    "itemIdSort sort direction requires an id filter to be present"));
        }

        if (containsInvalidFilters(filters) || doesNotHaveSearchPermissions(searchPermissions)) {
            return new SearchResults<>(Collections.emptyList(), 0, pageDto);
        }

        List<SearchFilter> nonEmptyFilters = filters.stream().filter(searchFilter -> !searchFilter.isEmpty())
            .collect(Collectors.toList());

        int totalCount = generalSearchRepository.getTotalItemsCount(searchPermissions, nonEmptyFilters);

        if (totalCount == 0) {
            return new SearchResults<>(Collections.emptyList(), 0, pageDto);
        }

        List<ItemSearchResult> slice = generalSearchRepository
            .findSlice(searchPermissions, pageDto, Collections.singletonList(handleDaysInWorkflowStatus(sort)),
                nonEmptyFilters);

        return new SearchResults<>(slice, totalCount, pageDto);
    }

    @Override
    public Optional<Map<String, Long>> getCounts(final List<SearchFilter> requestFilters,
                                                 final SearchProperty groupBy) {
        final SearchPermissions searchPermissions = permissionsMapper
            .transform(securityUtil.getItemBankUser().getAuthenticatedUser());

        if (containsInvalidFilters(requestFilters) || doesNotHaveSearchPermissions(searchPermissions)) {
            return Optional.empty();
        }

        List<SearchFilter> filters = new ArrayList<>(requestFilters);
        filters.add(new PermissionsBasedSearchFilter());

        return Optional.of(generalSearchRepository.getGroupCounts(searchPermissions, groupBy, filters));
    }

    private void validatePage(PageDto pageDto) {
        if (pageDto.getPageNumber() < 0) {
            throw new IllegalArgumentException("Page number must be greater than or equal zero");
        }

        if (pageDto.getPageSize() > itemSearchServiceProperties.getMaxSearchResults() || pageDto.getPageSize() < 1) {
            throw new IllegalArgumentException("Number of results for a single page must be between 1 to 1000");
        }
    }

    //TODO - Look if there is better way to handle this so it isn't so explicit.
    private Sort handleDaysInWorkflowStatus(Sort sort) {
        if (!sort.getSearchProperty().equals(DAYS_IN_WORKFLOW_STATUS)) {
            return sort;
        }

        /*
        Days in workflow status is a derived field at query time.  THe sorting needs to be flipped from the request
        so that asc sorts by the newest date to oldest and vice versa.
         */
        Sort.Direction direction = ASC == sort.getDirection() ? Sort.Direction.DESC : Sort.Direction.ASC;

        return new Sort(sort.getSearchProperty().getProperty(), direction);
    }

    private boolean containsInvalidFilters(List<SearchFilter> filters) {
        return filters.stream().anyMatch(searchFilter -> !searchFilter.containsValidFilterValues());
    }

    private boolean doesNotHaveSearchPermissions(final SearchPermissions searchPermissions) {
        return !searchPermissions.getPreviewAll().isPresent()
            && !searchPermissions.getPreviewVersion().isPresent()
            && !searchPermissions.getItemTypeToWorkflows().isEmpty()
            && !searchPermissions.getItemTypeToAssigneeWorkflows().isEmpty();
    }
}
