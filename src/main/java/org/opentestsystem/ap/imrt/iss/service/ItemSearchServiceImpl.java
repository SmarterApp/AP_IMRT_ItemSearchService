package org.opentestsystem.ap.imrt.iss.service;

import org.opentestsystem.ap.imrt.iss.config.ItemSearchServiceProperties;
import org.opentestsystem.ap.imrt.iss.dto.ItemSearchResult;
import org.opentestsystem.ap.imrt.iss.dto.SearchResults;
import org.opentestsystem.ap.imrt.iss.dto.search.PageDto;
import org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty;
import org.opentestsystem.ap.imrt.iss.dto.search.Sort;
import org.opentestsystem.ap.imrt.iss.model.IdMatchSearchFilter;
import org.opentestsystem.ap.imrt.iss.model.SearchFilter;
import org.opentestsystem.ap.imrt.iss.repository.GeneralSearchRepository;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.DAYS_IN_WORKFLOW_STATUS;
import static org.opentestsystem.ap.imrt.iss.dto.search.Sort.Direction.ASC;
import static org.opentestsystem.ap.imrt.iss.dto.search.Sort.Direction.ITEM_ID_ORDER;

@Service
public class ItemSearchServiceImpl implements ItemSearchService {
    private final GeneralSearchRepository generalSearchRepository;
    private final ItemSearchServiceProperties itemSearchServiceProperties;

    public ItemSearchServiceImpl(final GeneralSearchRepository generalSearchRepository,
                                 final ItemSearchServiceProperties itemSearchServiceProperties) {
        this.generalSearchRepository = generalSearchRepository;
        this.itemSearchServiceProperties = itemSearchServiceProperties;
    }

    @Override
    public SearchResults<ItemSearchResult> searchItems(final List<SearchFilter> filters, final Sort sort, final PageDto pageDto) {
        validatePage(pageDto);

        //Item ID order sort has specific rules
        if(ITEM_ID_ORDER.equals(sort.getDirection())) {
            if(!SearchProperty.ITEM_ID.equals(sort.getSearchProperty())) {
                throw new IllegalArgumentException("itemIdSort sort direction requires the sort property to be " + SearchProperty.ITEM_ID.getProperty());
            }

            //This needs to downcast because TIMS sends the item id filter each time regardless if it needs to be filtered
            filters.stream()
                    .filter(searchFilter -> SearchProperty.ITEM_ID.equals(searchFilter.getFilterProperty()))
                    .filter(searchFilter -> !((IdMatchSearchFilter)searchFilter).getIdFilterValues().isEmpty())
                    .findAny()
                    .orElseThrow(() -> new IllegalArgumentException("itemIdSort sort direction requires an id filter to be present"));
        }

        if (containsInvalidFilters(filters)) {
            return new SearchResults<>(Collections.emptyList(), 0, pageDto);
        }

        int totalCount = generalSearchRepository.getTotalItemsCount(filters);

        if (totalCount == 0) {
            return new SearchResults<>(Collections.emptyList(), 0, pageDto);
        }

        List<ItemSearchResult> slice = generalSearchRepository.findSlice(pageDto, Collections.singletonList(handleDaysInWorkflowStatus(sort)), filters);

        return new SearchResults<>(slice, totalCount, pageDto);
    }

    @Override
    public Optional<Map<String, Long>> getCounts(final List<SearchFilter> filters, final SearchProperty groupBy) {
        if (containsInvalidFilters(filters)) {
            return Optional.empty();
        }

        return Optional.of(generalSearchRepository.getGroupCounts(groupBy, filters));
    }

    private void validatePage(PageDto pageDto) {
        if (pageDto.getPageNumber() < 0) {
            throw new IllegalArgumentException("Page number must be greater than or equal zero");
        }

        if (pageDto.getPageSize() > itemSearchServiceProperties.getMaxSearchResults() || pageDto.getPageSize() < 1) {
            throw new IllegalArgumentException("Number of results for a single page must be between 1 to 1000");
        }
    }

    //TODO - Look if there is better way to handle this so it isn't so explicit.
    private Sort handleDaysInWorkflowStatus(Sort sort) {
        if (!sort.getSearchProperty().equals(DAYS_IN_WORKFLOW_STATUS)) {
            return sort;
        }

        /*
        Days in workflow status is a derived field at query time.  THe sorting needs to be flipped from the request
        so that asc sorts by the newest date to oldest and vice versa.
         */
        Sort.Direction direction = ASC == sort.getDirection() ? Sort.Direction.DESC : Sort.Direction.ASC;

        return new Sort(sort.getSearchProperty().getProperty(), direction);
    }

    private boolean containsInvalidFilters(List<SearchFilter> filters) {
        return filters.stream().anyMatch(searchFilter -> !searchFilter.containsValidFilterValues());
    }
}
