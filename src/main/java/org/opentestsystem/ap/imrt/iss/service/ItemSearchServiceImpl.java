package org.opentestsystem.ap.imrt.iss.service;

import org.opentestsystem.ap.imrt.common.model.BaseItem;
import org.opentestsystem.ap.imrt.common.service.OperationalEventService;
import org.opentestsystem.ap.imrt.iss.dto.search.PageDto;
import org.opentestsystem.ap.imrt.iss.model.SearchFilter;
import org.opentestsystem.ap.imrt.iss.repository.BaseItemSearchRepository;
import org.opentestsystem.ap.imrt.iss.repository.ItemSearchGroupAndCountRepository;
import org.opentestsystem.ap.imrt.iss.service.filter.FilterProcessor;
import org.opentestsystem.ap.imrt.iss.service.filter.ImrtSearchIndexProperties;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.Specifications;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.DAYS_IN_WORKFLOW_STATUS;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.DOK;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.GRADE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ITEM_AUTHOR;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ITEM_DIFFICULTY_QUINTILE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ITEM_ID;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ITEM_TYPE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ORG_NAME;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ORG_TYPE_ID;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.PRIMARY_CLAIM;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.PRIMARY_TARGET;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.SUBJECT;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.TTS_SIGHT_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.TTS_VISUAL_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.TTS_VISUAL_REQUIRED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.WORKFLOW_STATUS;
import static org.opentestsystem.ap.imrt.iss.dto.search.Sort.Direction.ASC;
import static org.opentestsystem.ap.imrt.iss.service.filter.ImrtSearchIndexProperties.getImrtSearchProperty;

@Service
public class ItemSearchServiceImpl implements ItemSearchService {
    private static final Logger LOG = LoggerFactory.getLogger(ItemSearchServiceImpl.class);
    private final OperationalEventService logger;
    private static final Map<String, String> COUNTS_TO_FIELDS;

    static {
        Map<String, String> countsToFields = new HashMap<>();
        countsToFields.put(ITEM_ID, "id");
        countsToFields.put(GRADE, "grade");
        countsToFields.put(WORKFLOW_STATUS, "workflowStatus");
        countsToFields.put(ITEM_TYPE, "itemType");
        countsToFields.put(SUBJECT, "subject");
        countsToFields.put(ORG_TYPE_ID, "organizationTypeId");
        countsToFields.put(ORG_NAME, "organizationName");
        countsToFields.put(PRIMARY_CLAIM, "primaryClaim");
        countsToFields.put(PRIMARY_TARGET, "primaryTarget");
        countsToFields.put(ITEM_AUTHOR, "itemAuthor");
        countsToFields.put(DOK, "depthOfKnowledge");
        countsToFields.put(ITEM_DIFFICULTY_QUINTILE, "itemDifficultyQuintile");
        countsToFields.put(TTS_SIGHT_PROVIDED, "isSightTTSProvided");
        countsToFields.put(TTS_VISUAL_PROVIDED, "isVisualTTSProvided");
        countsToFields.put(TTS_VISUAL_REQUIRED, "isVisualTTSRequired");

        COUNTS_TO_FIELDS = Collections.unmodifiableMap(countsToFields);
    }


    private final BaseItemSearchRepository baseItemSearchRepository;
    private final FilterProcessor<BaseItem> filterProcessor;
    private final ItemSearchGroupAndCountRepository itemSearchGroupAndCountRepository;

    public ItemSearchServiceImpl(final BaseItemSearchRepository baseItemSearchRepository,
                                 final FilterProcessor<BaseItem> filterProcessor,
                                 final ItemSearchGroupAndCountRepository itemSearchGroupAndCountRepository,
                                 final OperationalEventService logger) {
        this.baseItemSearchRepository = baseItemSearchRepository;
        this.filterProcessor = filterProcessor;
        this.itemSearchGroupAndCountRepository = itemSearchGroupAndCountRepository;
        this.logger = logger;
    }

    @Override
    public Optional<Page<BaseItem>> searchItems(final List<SearchFilter> filters, final org.opentestsystem.ap.imrt.iss.dto.search.Sort sort, final PageDto pageDto) {
        if (isFiltersInvalid(filters)) {
            return Optional.empty();
        }

        Optional<Specifications<BaseItem>> maybeSpecifications;
        maybeSpecifications = filterProcessor.processFilters(filters);
        PageRequest pageRequest = mapPageAndSort(pageDto, sort);

        //If there are no filters or if the filters sent are not supported there will not be any specifications to run.
        return maybeSpecifications.map(baseItemSpecifications -> Optional.of(baseItemSearchRepository.findAll(baseItemSpecifications, pageRequest)))
                .orElseGet(() -> Optional.of(baseItemSearchRepository.findAll(pageRequest)));
    }

    @Override
    public Optional<Map<String, Long>> getCounts(final List<SearchFilter> filters, final String groupBy) {
        if (isFiltersInvalid(filters)) {
            return Optional.empty();
        }

        if (!COUNTS_TO_FIELDS.containsKey(groupBy)) {
            logger.serviceWarning(LOG, null, "Unsupported group by property {}.  Please check API documentation", groupBy);
            throw new IllegalArgumentException(String.format("Unsupported group by property %s", groupBy));
        }

        Optional<Specifications<BaseItem>> maybeSpecifications = filterProcessor.processFilters(filters);

        final String groupByField = COUNTS_TO_FIELDS.get(groupBy);

        return maybeSpecifications.map(baseItemSpecifications -> Optional.of(itemSearchGroupAndCountRepository.getGroupCounts(groupByField, baseItemSpecifications)))
                .orElseGet(() -> Optional.of(itemSearchGroupAndCountRepository.getGroupCounts(groupByField)));
    }

    private PageRequest mapPageAndSort(PageDto pageDto, org.opentestsystem.ap.imrt.iss.dto.search.Sort sortDto) {
        Sort sort = mapSort(sortDto);

        if (pageDto.getPageNumber() < 0) {
            throw new IllegalArgumentException("Page number must be greater than or equal zero");
        }

        if (pageDto.getPageSize() > 1000) {
            throw new IllegalArgumentException("Number of results for a single page cannot be greater than 1000");
        }

        return new PageRequest(pageDto.getPageNumber(), pageDto.getPageSize(), sort);
    }

    private Sort mapSort(org.opentestsystem.ap.imrt.iss.dto.search.Sort sort) {
        Optional<String> maybeImrtItemProperty = getImrtSearchProperty(sort.getProperty());
        if (!maybeImrtItemProperty.isPresent()) {
            throw new IllegalArgumentException("Unsupported sort property selected: " + sort.getProperty());
        }

        Sort.Direction direction;

        /*
        Days in workflow status is a derived field at query time.  THe sorting needs to be flipped from the request
        so that asc sorts by the newest date to oldest and vice versa.
         */
        if (DAYS_IN_WORKFLOW_STATUS.equals(sort.getProperty())) {
            direction = ASC == sort.getDirection() ? Sort.Direction.DESC : Sort.Direction.ASC;
        } else {
            direction = ASC == sort.getDirection() ? Sort.Direction.ASC : Sort.Direction.DESC;
        }

        return new Sort(direction, maybeImrtItemProperty.get());
    }

    private boolean isFiltersInvalid(List<SearchFilter> filters) throws IllegalArgumentException {
        for (SearchFilter filter : filters) {
            if (!ImrtSearchIndexProperties.isValidImrtField(filter.getFilterProperty())) {
                throw new IllegalArgumentException(String.format("Invalid filter in search request: property = %s", filter.getFilterProperty()));
            }

            if (!filter.isValid()) {
                return true;
            }
        }

        return false;
    }
}
