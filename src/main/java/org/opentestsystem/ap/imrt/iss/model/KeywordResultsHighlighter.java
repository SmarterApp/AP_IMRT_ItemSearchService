package org.opentestsystem.ap.imrt.iss.model;

import com.fathzer.soft.javaluator.Operator;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.Pair;
import org.opentestsystem.ap.imrt.iss.config.ItemSearchServiceProperties;
import org.opentestsystem.ap.imrt.iss.dto.ItemSearchResult;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static java.lang.Math.max;
import static java.lang.Math.min;
import static java.util.stream.Collectors.toSet;
import static org.apache.commons.lang3.StringUtils.isBlank;

@Component
public class KeywordResultsHighlighter {
    private final static Pair<Integer,Integer> NO_MATCH = Pair.of(Integer.MIN_VALUE, Integer.MAX_VALUE);
    private final static Pair<Integer,Integer> MATCH_ALL = Pair.of(0, Integer.MAX_VALUE);

    private final ItemSearchServiceProperties properties;

    public KeywordResultsHighlighter(ItemSearchServiceProperties properties) {
        this.properties = properties;
    }

    /**
     * Uses the Keywords Filter expression to change the the keywordContents results to just the portion
     * that matched the expression plus some padding for context. This may be shortened if the matched
     * area is longer than the max allowed length.
     *
     * @param expression a filter expression matching the syntax define by Keyword filters.
     * @param itemSearchResults the list of results already returned by the database for the expression
     * @return the item search results with the keywordContent field pared down to the matching section
     */
    public List<ItemSearchResult> highlight(final String expression, final boolean caseSensitive,
                                            final List<ItemSearchResult> itemSearchResults) {

        final Set<String> results = itemSearchResults
                .stream()
                .map(ItemSearchResult::getKeywordContent)
                .collect(toSet());

        Map<String,String> highlights = highlightStrings(expression, caseSensitive, results);

        for (ItemSearchResult itemSearchResult : itemSearchResults) {
            String content = itemSearchResult.getKeywordContent();
            String highlightContent = StringUtils.trimToEmpty(highlights.get(content));
            itemSearchResult.setKeywordContent(highlightContent);
        }

        return itemSearchResults;
    }

    /**
     * Business logic of clipping and padding the content to the given matched range while keeping to
     * the defined maximum character length.
     *
     * @param content the full content from the data results
     * @param range the computed range for the match
     *
     * @return a string with all
     */
    private String clipToRange(String content, Pair<Integer,Integer> range) {
        // If no match, then return empty string.
        if (range == null || isBlank(content) || range == NO_MATCH) {
            return "";
        }

        // If full string matches, then return first max characters
        if (content.length() <= properties.getMaxKeywordContextLength()) {
            return content;
        } else if (range == MATCH_ALL) {
            return content.substring(0, properties.getMaxKeywordContextLength());
        }

        // If match range is bigger than max, then return max characters starting at left.
        int rangeLength = range.getRight() - range.getLeft();
        if (rangeLength >= properties.getMaxKeywordContextLength()) {
            return content.substring(range.getLeft(), range.getLeft() + properties.getMaxKeywordContextLength());
        }

        // String is less than MAX. Pad extra characters to highlight range up to the max, preferring to pad left.
        int totalPad = properties.getMaxKeywordContextLength() - rangeLength;

        int leftPad;
        if (totalPad > (properties.getMaxKeywordContextLength()/2)) {
            leftPad = totalPad / 2 + totalPad % 2;
        } else {
            leftPad = totalPad;
        }

        // Don't go negative
        leftPad = min(leftPad, range.getLeft());

        // Don't go past end of content
        int rightPad = min(totalPad - leftPad, content.length() - range.getRight());
        if (leftPad + rightPad < totalPad) {
            leftPad = (totalPad - rightPad);
        }

        // Try to get up to max.
        return content.substring(
                range.getLeft() - leftPad, range.getRight() + rightPad);
    }

    private Map<String, String> highlightStrings(String expression, boolean caseSensitive, Set<String> strings) {
        Map<String, Pair<Integer, Integer>> highlightRangeMap = computeHighlightRanges(expression, caseSensitive, strings);
        Map<String, String> highlightMap = new HashMap<>();

        for (Map.Entry<String, Pair<Integer, Integer>> entry : highlightRangeMap.entrySet()) {
            String content = entry.getKey();
            Pair<Integer,Integer> range = entry.getValue();
            highlightMap.put(content, clipToRange(content, range));
        }

        return highlightMap;
    }


    private Map<String,Pair<Integer,Integer>> computeHighlightRanges(final String expression,
                                                     final boolean caseSensitive, final Set<String> results) {

        KeywordSearchToRegexEvaluator<Map<String,Pair<Integer, Integer>>> evaluator =
            new KeywordSearchToRegexEvaluator<Map<String,Pair<Integer, Integer>>>() {
                @Override
                protected Map<String, Pair<Integer, Integer>> convertRegexToken(String regexToken) {
                    final Pattern pattern = caseSensitive ?
                            Pattern.compile(regexToken) : Pattern.compile(regexToken, Pattern.CASE_INSENSITIVE);

                    Map<String, Pair<Integer, Integer>> ranges = new HashMap<>();
                    for (String result : results) {
                        Matcher matcher = pattern.matcher(result);

                        if (matcher.find()) {
                            ranges.put(result, Pair.of(matcher.start(), matcher.end()));
                        } else {
                            ranges.put(result, NO_MATCH);
                        }
                    }

                    return ranges;
                }

                @Override
                protected Map<String,Pair<Integer, Integer>> evaluate(
                        Operator operator,
                        Iterator<Map<String,Pair<Integer, Integer>>> operands, Object evaluationContext)
                {
                    Map<String,Pair<Integer, Integer>> ranges = new HashMap<>();
                    Map<String,Pair<Integer, Integer>> o1 = operands.next();
                    Map<String,Pair<Integer, Integer>> o2 = operands.hasNext() ? operands.next() : null;

                    for (String result : results) {
                        Pair<Integer,Integer> newRange;

                        if (isNegate(operator)) {
                            Pair<Integer,Integer> o1Range = o1.get(result);
                            newRange = (o1Range == NO_MATCH) ? MATCH_ALL : NO_MATCH;
                        } else if (isAnd(operator)) {
                            if (o2 == null) {
                                throw new IllegalArgumentException("Missing second operand for AND expression");
                            }

                            Pair<Integer,Integer> o1Range = o1.get(result);
                            Pair<Integer,Integer> o2Range = o2.get(result);

                            if (o1Range == NO_MATCH || o2Range == NO_MATCH) {
                                newRange = NO_MATCH;
                            } else if (o1Range == MATCH_ALL || o2Range== MATCH_ALL) {
                                newRange = o1Range == MATCH_ALL ? o2Range : o1Range;
                            } else {
                                newRange = Pair.of(min(o1Range.getLeft(), o2Range.getLeft()),
                                        max(o1Range.getRight(), o2Range.getRight()));
                            }
                        } else if (isOr(operator)) {
                            if (o2 == null) {
                                throw new IllegalArgumentException("Missing second operand for OR expression");
                            }

                            Pair<Integer,Integer> o1Range = o1.get(result);
                            Pair<Integer,Integer> o2Range = o2.get(result);

                            if (o1Range == NO_MATCH || o2Range == NO_MATCH) {
                                newRange = (o1Range == NO_MATCH) ? o2Range : o1Range;
                            } else if (o1Range == MATCH_ALL || o2Range == MATCH_ALL) {
                                newRange = (o1Range == MATCH_ALL) ? o2Range : o1Range;
                            } else {
                                newRange = matchLength(o1Range) <= matchLength(o2Range) ? o1Range : o2Range;
                            }
                        } else {
                            newRange = NO_MATCH;
                        }

                        ranges.put(result, newRange);
                    }

                    return ranges;
                }

                private int matchLength(Pair<Integer,Integer> match) {
                    return match.getRight() - match.getLeft();
                }
            };

        return evaluator.evaluate(expression);
    }
}
