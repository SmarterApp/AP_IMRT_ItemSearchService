package org.opentestsystem.ap.imrt.iss.model;

import com.fathzer.soft.javaluator.Operator;
import org.apache.commons.lang3.tuple.Pair;
import org.opentestsystem.ap.imrt.iss.config.ItemSearchServiceProperties;
import org.springframework.stereotype.Component;

import java.util.Iterator;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static java.lang.Math.max;
import static java.lang.Math.min;
import static org.apache.commons.lang3.StringUtils.isBlank;
import static org.apache.commons.lang3.StringUtils.trimToEmpty;

/**
 * Highlights content to emphasize a matching region based on the keyword search string.
 */
@Component
public class KeywordResultsHighlighter {
    private final static Pair<Integer,Integer> NO_MATCH = Pair.of(Integer.MIN_VALUE, Integer.MAX_VALUE);
    private final static Pair<Integer,Integer> MATCH_ALL = Pair.of(0, Integer.MAX_VALUE);

    private final ItemSearchServiceProperties properties;

    public KeywordResultsHighlighter(ItemSearchServiceProperties properties) {
        this.properties = properties;
    }

    /**
     * Uses the Keywords search expression to reduce the given content to just the matched region.
     * For short matched regions, the region may be padded with the content surrounding the
     * matched region for context. For long matched regions, the region may be truncated, and
     * only part of the match returned. 
     *
     * @param expression a filter expression matching the syntax define by Keyword filters.
     * @param content the content to highlight
     * @return a substring of content representing the highlighted region
     */
    @SuppressWarnings("WeakerAccess")
    public String highlight(final String expression, final boolean caseSensitive,
                            final String content) {

        Pair<Integer,Integer> range = computeHighlightRange(expression, caseSensitive, content);
        return trimToEmpty(clipToRange(content, range));
    }

    /**
     * Business logic of clipping and padding the content to the given matched range while keeping to
     * the defined maximum character length.
     *
     * @param content the full content from the data results
     * @param range the computed range for the match
     *
     * @return a string with all
     */
    private String clipToRange(String content, Pair<Integer,Integer> range) {
        // If no match, then return empty string.
        if (range == null || isBlank(content) || range == NO_MATCH) {
            return "";
        }

        // If full string matches, then return first max characters
        if (content.length() <= properties.getMaxKeywordContextLength()) {
            return content;
        } else if (range == MATCH_ALL) {
            return content.substring(0, properties.getMaxKeywordContextLength());
        }

        // If match range is bigger than max, then return max characters starting at left.
        int rangeLength = range.getRight() - range.getLeft();
        if (rangeLength >= properties.getMaxKeywordContextLength()) {
            return content.substring(range.getLeft(), range.getLeft() + properties.getMaxKeywordContextLength());
        }

        // String is less than MAX. Pad extra characters to highlight range up to the max, preferring to pad left.
        int totalPad = properties.getMaxKeywordContextLength() - rangeLength;

        int leftPad;
        if (totalPad > (properties.getMaxKeywordContextLength()/2)) {
            leftPad = totalPad / 2 + totalPad % 2;
        } else {
            leftPad = totalPad;
        }

        // Don't go negative
        leftPad = min(leftPad, range.getLeft());

        // Don't go past end of content
        int rightPad = min(totalPad - leftPad, content.length() - range.getRight());
        if (leftPad + rightPad < totalPad) {
            leftPad = (totalPad - rightPad);
        }

        // Try to get up to max.
        return content.substring(
                range.getLeft() - leftPad, range.getRight() + rightPad);
    }

    
    private Pair<Integer,Integer> computeHighlightRange(final String expression, final boolean caseSensitive,
                                                        final String content) {
        if (isBlank(expression)) {
            return MATCH_ALL;
        }

        KeywordSearchToRegexEvaluator<Pair<Integer, Integer>> evaluator =
                new KeywordSearchToRegexEvaluator<Pair<Integer, Integer>>() {

                    @Override
                    protected Pair<Integer, Integer> convertRegexToken(String regexToken) {
                        final Pattern pattern = caseSensitive ?
                                Pattern.compile(regexToken) : Pattern.compile(regexToken, Pattern.CASE_INSENSITIVE);

                        Matcher matcher = pattern.matcher(content);

                        if (matcher.find()) {
                            return Pair.of(matcher.start(), matcher.end());
                        }

                        return NO_MATCH;
                    }

                    @Override
                    protected Pair<Integer, Integer> evaluate(
                            Operator operator,
                            Iterator<Pair<Integer, Integer>> operands, Object evaluationContext)
                    {
                        Pair<Integer, Integer> o1 = operands.next();
                        Pair<Integer, Integer> o2 = operands.hasNext() ? operands.next() : null;

                        Pair<Integer,Integer> newRange;

                        if (isNegate(operator)) {
                            newRange = (o1 == NO_MATCH) ? MATCH_ALL : NO_MATCH;
                        } else if (isAnd(operator)) {
                            if (o2 == null) {
                                throw new IllegalArgumentException("Missing second operand for AND expression");
                            }

                            if (o1 == NO_MATCH || o2 == NO_MATCH) {
                                newRange = NO_MATCH;
                            } else if (o1 == MATCH_ALL || o2 == MATCH_ALL) {
                                newRange = o1 == MATCH_ALL ? o2 : o1;
                            } else {
                                newRange = Pair.of(min(o1.getLeft(), o2.getLeft()),
                                        max(o1.getRight(), o2.getRight()));
                            }
                        } else if (isOr(operator)) {
                            if (o2 == null) {
                                throw new IllegalArgumentException("Missing second operand for OR expression");
                            }

                            if (o1 == NO_MATCH || o2 == NO_MATCH) {
                                newRange = (o1 == NO_MATCH) ? o2 : o1;
                            } else if (o1 == MATCH_ALL || o2 == MATCH_ALL) {
                                newRange = (o1 == MATCH_ALL) ? o2 : o1;
                            } else {
                                newRange = matchLength(o1) <= matchLength(o2) ? o1 : o2;
                            }

                        } else {
                            newRange = NO_MATCH;
                        }

                        return newRange;
                    }

                    private int matchLength(Pair<Integer,Integer> match) {
                        return match.getRight() - match.getLeft();
                    }
                };

        return evaluator.evaluate(expression);
    }
}
