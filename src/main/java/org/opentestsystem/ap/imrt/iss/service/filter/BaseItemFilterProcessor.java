package org.opentestsystem.ap.imrt.iss.service.filter;

import org.opentestsystem.ap.imrt.common.model.BaseItem;
import org.opentestsystem.ap.imrt.common.service.OperationalEventService;
import org.opentestsystem.ap.imrt.iss.dto.search.BooleanFlagFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.Filter;
import org.opentestsystem.ap.imrt.iss.dto.search.IntegerRangeFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.MatchFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.NumberOfDaysRangeFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.data.jpa.domain.Specifications;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import static org.opentestsystem.ap.imrt.iss.service.filter.BaseItemFilterSpecifications.isBetween;
import static org.opentestsystem.ap.imrt.iss.service.filter.BaseItemFilterSpecifications.isBetweenHalfOpen;
import static org.opentestsystem.ap.imrt.iss.service.filter.BaseItemFilterSpecifications.isIn;
import static org.opentestsystem.ap.imrt.iss.service.filter.BaseItemFilterSpecifications.isLessThan;
import static org.opentestsystem.ap.imrt.iss.service.filter.BaseItemFilterSpecifications.isValue;

/**
 * Handle processing filter options for {@link BaseItem}
 */
@Component
public class BaseItemFilterProcessor implements FilterProcessor<BaseItem> {
    private static final Logger LOG = LoggerFactory.getLogger(BaseItemFilterProcessor.class);
    private final OperationalEventService logger;

    @Autowired
    public BaseItemFilterProcessor(final OperationalEventService logger) {
        this.logger = logger;
    }

    @Override
    public Optional<Specifications<BaseItem>> processFilters(final List<Filter> filters) {
        List<Specification<BaseItem>> specifications = new ArrayList<>();

        for (Filter filter : filters) {
            Optional<Specification<BaseItem>> maybeSpec = processFilter(filter);

            if (maybeSpec.isPresent()) {
                specifications.add(maybeSpec.get());
            } else {
                logger.serviceWarning(LOG, null, "Could not map specification for filter type {} and property {}", filter.getType(), filter.getProperty());
            }
        }

        //If there are no filters or if the filters sent are not supported there will not be any specifications to run.
        if (specifications.isEmpty()) {
            return Optional.empty();
        }

        //For the first phase of IMRT we "AND" all filters.
        Specifications<BaseItem> spec = null;
        for (Specification<BaseItem> specification : specifications) {
            if (spec == null) {
                spec = Specifications.where(specification);
                continue;
            }

            spec = spec.and(specification);
        }

        return Optional.of(spec);
    }

    @Override
    public Optional<Specification<BaseItem>> processFilter(Filter filter) {
        if (!FilterProperty.isSupportedFilterForProperty(filter)) {
            return Optional.empty();
        }

        /*
        Using instanceof here instead of adding the filter -> specification mapping
        to the Filter objects themselves.  The reason for doing it this way is our client
        facing objects are simple POJO's and do not know about the underlying data query
        implementation.
         */
        if (filter instanceof MatchFilter) {
            return process((MatchFilter) filter);
        } else if (filter instanceof NumberOfDaysRangeFilter) {
            return process((NumberOfDaysRangeFilter) filter);
        } else if (filter instanceof IntegerRangeFilter) {
            return process((IntegerRangeFilter) filter);
        } else if (filter instanceof BooleanFlagFilter) {
            return process((BooleanFlagFilter) filter);
        }

        //This means that a filter type is passed to this processor that is not handled.
        //This is most likely a coding issue and should be logged at the caller
        return Optional.empty();
    }

    private Optional<Specification<BaseItem>> process(MatchFilter matchFilter) {
        return Optional.of(isIn(getImrtFilterProperty(matchFilter), matchFilter.getValues()));
    }

    private Optional<Specification<BaseItem>> process(IntegerRangeFilter integerRangeFilter) {
        return Optional.of(isBetween(getImrtFilterProperty(integerRangeFilter),
                integerRangeFilter.getMin(),
                integerRangeFilter.getMax()));
    }

    private Optional<Specification<BaseItem>> process(BooleanFlagFilter booleanFlagFilter) {
        return Optional.of(isValue(getImrtFilterProperty(booleanFlagFilter), booleanFlagFilter.isValue()));
    }

    /**
     * Process the {@link org.opentestsystem.ap.imrt.iss.dto.search.NumberOfDaysRangeFilter}.
     * <p>
     * If the min and max values are provided, then build a "half-open" BETWEEN criteria.  If only min is provided,
     * build a less-than criteria.
     * </p>
     *
     * @param numberOfDaysRangeFilter The {@link org.opentestsystem.ap.imrt.iss.dto.search.NumberOfDaysRangeFilter} being processed.
     * @return A {@link org.springframework.data.jpa.domain.Specification<org.opentestsystem.ap.imrt.common.model.BaseItem>}
     * with the appropriate criteria based on the filter's input.
     */
    private Optional<Specification<BaseItem>> process(final NumberOfDaysRangeFilter numberOfDaysRangeFilter) {
        if (numberOfDaysRangeFilter.getMax().isPresent()) {
            // Trim off the time; we're only interested in the date (mm/yy/dddd).
            final Instant oldestDate = Instant.now().minus(numberOfDaysRangeFilter.getMax().get(), ChronoUnit.DAYS)
                    .truncatedTo(ChronoUnit.DAYS);

            // Get the beginning of the next day _after_ the most recent date the caller is interested in.  The "min"
            // value here means "minimum number fo day(s)", so we need to decrement min by 1 to get the beginning of the
            // next day _after_ the most recent date.  E.g. if today is 10apr18 and we want everything between 5 and 10
            // days old, the query is "WHERE date_field >= 01apr18 AND date_field < 06apr18.
            // Trim off the time; we're only interested in the date (mm/yy/dddd).
            final Instant mostRecentDate =
                    Instant.now().minus(numberOfDaysRangeFilter.getMin() - 1, ChronoUnit.DAYS)
                            .truncatedTo(ChronoUnit.DAYS);

            return Optional.of(isBetweenHalfOpen(getImrtFilterProperty(numberOfDaysRangeFilter),
                    Instant.from(oldestDate),
                    Instant.from(mostRecentDate)));
        } else {
            // Get everything less than the beginning of the next day.  E.g. if today is 10apr18 and we want everything
            // five days old or older, then the query is "WHERE date_field < 06par18 00:00:00.000".
            final Instant cutOffDate = Instant.now().minus(numberOfDaysRangeFilter.getMin() - 1, ChronoUnit.DAYS)
                    .truncatedTo(ChronoUnit.DAYS);
            return Optional.of(isLessThan(getImrtFilterProperty(numberOfDaysRangeFilter), cutOffDate));
        }
    }

    private String getImrtFilterProperty(Filter filter) {
        return FilterProperty.getImrtSearchProperty(filter.getProperty())
                .orElseThrow(() -> new IllegalArgumentException(
                        String.format("Invalid property %s for filter type %s", filter.getProperty(), filter.getType()))
                );
    }


}

