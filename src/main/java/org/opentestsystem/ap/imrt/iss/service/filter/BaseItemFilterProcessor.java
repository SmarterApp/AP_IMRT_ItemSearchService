package org.opentestsystem.ap.imrt.iss.service.filter;

import org.opentestsystem.ap.imrt.common.model.BaseItem;
import org.opentestsystem.ap.imrt.iss.dto.search.Filter;
import org.opentestsystem.ap.imrt.iss.dto.search.IntegerRangeFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.MatchFilter;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Component;

import javax.persistence.criteria.Expression;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

/**
 * Handle processing filter options for
 */
@Component
public class BaseItemFilterProcessor implements FilterProcessor<BaseItem> {
    private static final Map<String, String> FILTER_TO_FIElDS;

    static {
        Map<String, String> filterToFields = new HashMap<>();
        filterToFields.put("itemId", "id");
        filterToFields.put("grade", "grade");
        filterToFields.put("stimulusId", "associatedStimulusId");
        filterToFields.put("depthOfKnowledge", "depthOfKnowledge");
        filterToFields.put("workflowStatus", "workflowStatus");
        filterToFields.put("itemType", "itemType");
        filterToFields.put("subject", "subject");

        FILTER_TO_FIElDS = Collections.unmodifiableMap(filterToFields);
    }

    @Override
    public Optional<Specification<BaseItem>> processFilter(Filter filter) {
        if (!FILTER_TO_FIElDS.containsKey(filter.getProperty())) {
            return Optional.empty();
        }

        if (filter instanceof MatchFilter) {
            return process((MatchFilter) filter);
        } else if (filter instanceof IntegerRangeFilter) {
            return process((IntegerRangeFilter) filter);
        }

        //This means that a filter type is passed to this processor that is not handled.
        //This is most likely a coding issue and should be logged at the caller
        return Optional.empty();
    }

    private Optional<Specification<BaseItem>> process(MatchFilter matchFilter) {
        return Optional.of(isIn(FILTER_TO_FIElDS.get(matchFilter.getProperty()), matchFilter.getValues()));
    }

    private Optional<Specification<BaseItem>> process(IntegerRangeFilter integerRangeFilter) {
        return Optional.empty();
    }

    private static Specification<BaseItem> isIn(final String field, final Collection<String> values) {
        return (root, query, cb) -> {
            Expression<String> exp = root.get(field);
            return exp.in(values);
        };
    }
}

