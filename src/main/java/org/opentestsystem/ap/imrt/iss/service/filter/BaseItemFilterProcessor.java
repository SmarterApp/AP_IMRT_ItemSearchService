package org.opentestsystem.ap.imrt.iss.service.filter;

import org.opentestsystem.ap.imrt.common.model.BaseItem;
import org.opentestsystem.ap.imrt.iss.dto.search.DaysRangeFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.Filter;
import org.opentestsystem.ap.imrt.iss.dto.search.IntegerRangeFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.MatchFilter;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Component;

import javax.persistence.criteria.Expression;
import javax.persistence.criteria.Predicate;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Collection;
import java.util.Optional;

/**
 * Handle processing filter options for {@link BaseItem}
 */
@Component
public class BaseItemFilterProcessor implements FilterProcessor<BaseItem> {
    @Override
    public Optional<Specification<BaseItem>> processFilter(Filter filter) {
        if (!FilterProperty.isSupportedFilterForProperty(filter)) {
            return Optional.empty();
        }

        /*
        Using instanceof here instead of adding the filter -> specification mapping
        to the Filter objects themselves.  The reason for doing it this way is our client
        facing objects are simple POJO's and do not know about the underlying data query
        implementation.
         */
        if (filter instanceof MatchFilter) {
            return process((MatchFilter) filter);
        } else if (filter instanceof DaysRangeFilter) {
            return process((DaysRangeFilter) filter);
        } else if (filter instanceof IntegerRangeFilter) {
            return process((IntegerRangeFilter) filter);
        }

        //This means that a filter type is passed to this processor that is not handled.
        //This is most likely a coding issue and should be logged at the caller
        return Optional.empty();
    }

    private Optional<Specification<BaseItem>> process(MatchFilter matchFilter) {
        return Optional.of(isIn(getImrtFilterProperty(matchFilter), matchFilter.getValues()));
    }

    private Optional<Specification<BaseItem>> process(IntegerRangeFilter integerRangeFilter) {
        return Optional.of(isBetween(getImrtFilterProperty(integerRangeFilter),
                integerRangeFilter.getMin(),
                integerRangeFilter.getMax()));
    }

    /**
     * Process the {@link org.opentestsystem.ap.imrt.iss.dto.search.DaysRangeFilter}.
     * <p>
     * If the min and max values are provided, then build a "half-open" BETWEEN criteria.  If only max is provided,
     * build a greater-than-or-equal-to criteria.
     * </p>
     *
     * @param daysRangeFilter The {@link org.opentestsystem.ap.imrt.iss.dto.search.DaysRangeFilter} being processed.
     * @return A {@link org.springframework.data.jpa.domain.Specification<org.opentestsystem.ap.imrt.common.model.BaseItem>}
     * with the appropriate criteria based on the filter's input.
     */
    private Optional<Specification<BaseItem>> process(final DaysRangeFilter daysRangeFilter) {
        // Trim off the time; we're only interested in the date (mm/yy/dddd).
        final Instant oldestDate = Instant.now().minus(daysRangeFilter.getMax(), ChronoUnit.DAYS)
                .truncatedTo(ChronoUnit.DAYS);

        if (daysRangeFilter.getMin().isPresent()) {
            // Get the beginning of the next day _after_ the most recent date the caller is interested in.  The "min"
            // value here means "most recent day", so we need to decrement min by 1 to get the beginning of the next day
            // _after_ the most recent date.
            // Trim off the time; we're only interested in the date (mm/yy/dddd).
            final Instant mostRecentDate =
                    Instant.now().minus(daysRangeFilter.getMin().get() - 1, ChronoUnit.DAYS)
                            .truncatedTo(ChronoUnit.DAYS);

            return Optional.of(isBetweenHalfOpen(getImrtFilterProperty(daysRangeFilter),
                    Instant.from(oldestDate),
                    Instant.from(mostRecentDate)));
        } else {
            return Optional.of(isGreaterThanOrEqualTo(getImrtFilterProperty(daysRangeFilter), oldestDate));
        }
    }

    /**
     * A {@link org.springframework.data.jpa.domain.Specification} for specifying a group of values as criteria.
     * <p>
     * This will emit an IN criteria to the SQL generated by JPA.
     * </p>
     *
     * @param field  The database field that is the subject of this criteria
     * @param values The collection of values to include in the IN clause
     * @return A {@link org.springframework.data.jpa.domain.Specification<org.opentestsystem.ap.imrt.common.model.BaseItem>}
     * * with the appropriate criteria based on the filter's input.
     */
    private static Specification<BaseItem> isIn(final String field, final Collection<String> values) {
        return (root, query, cb) -> {
            Expression<String> exp = root.get(field);
            return exp.in(values);
        };
    }

    /**
     * A {@link org.springframework.data.jpa.domain.Specification} for an inclusive between for a range of
     * integer/number values.
     * <p>
     * This will emit BETWEEN criteria to the SQL generated by JPA.  For example, if the request is "show me all
     * the records between 1 and 10", both 1 and 10 will be included in the result set.
     * </p>
     *
     * @param field    The database field that is the subject of this criteria
     * @param minValue The minimum value of the BETWEEN statement
     * @param maxValue The maximum value of the BETWEEN statement
     * @return A {@link org.springframework.data.jpa.domain.Specification<org.opentestsystem.ap.imrt.common.model.BaseItem>}
     * with the appropriate criteria based on the filter's input.
     */
    private static Specification<BaseItem> isBetween(final String field, final int minValue, final int maxValue) {
        return (root, query, cb) -> cb.between(root.get(field), minValue, maxValue);
    }

    /**
     * A {@link org.springframework.data.jpa.domain.Specification} for "half open" implementation for fetching records
     * between two {@link java.time.Instant}s.
     * <p>
     * This will emit "date_field >= [my minimum date] AND date_field < [may maximum date]" to the SQL generated by JPA.
     * </p>
     *
     * @param field   field The database field that is the subject of this criteria
     * @param minDate The minimum value as the operand for the greater-than-or-equal-to half of the comparison
     * @param maxDate The maximum value as the operand for the less-than half of the comparison
     * @return A {@link org.springframework.data.jpa.domain.Specification<org.opentestsystem.ap.imrt.common.model.BaseItem>}
     * * with the appropriate criteria based on the filter's input.
     */
    private static Specification<BaseItem> isBetweenHalfOpen(final String field,
                                                             final Instant minDate,
                                                             final Instant maxDate) {
        return (root, query, cb) -> {
            final Predicate greaterThanOrEqualToPredicate = cb.greaterThanOrEqualTo(root.get(field), minDate);
            final Predicate lessThanPredicate = cb.lessThan(root.get(field), maxDate);
            return cb.and(greaterThanOrEqualToPredicate, lessThanPredicate);
        };
    }

    /**
     * A greater-than-or-equal-to {@link org.springframework.data.jpa.domain.Specification} for fetching all records
     * greater than or equal to an {@link java.time.Instant}.
     *
     * @param field   field The database field that is the subject of this criteria
     * @param minDate The minimum value as the operand for the greater-than-or-equal-to comparison
     * @return A {@link org.springframework.data.jpa.domain.Specification<org.opentestsystem.ap.imrt.common.model.BaseItem>}
     * * * with the appropriate criteria based on the filter's input.
     */
    private static Specification<BaseItem> isGreaterThanOrEqualTo(final String field, final Instant minDate) {
        return (root, query, cb) -> cb.greaterThanOrEqualTo(root.get(field), minDate);
    }

    private String getImrtFilterProperty(Filter filter) {
        return FilterProperty.getImrtSearchProperty(filter.getProperty())
                .orElseThrow(() -> new IllegalArgumentException(
                        String.format("Invalid property %s for filter type %s", filter.getProperty(), filter.getType()))
                );
    }
}

