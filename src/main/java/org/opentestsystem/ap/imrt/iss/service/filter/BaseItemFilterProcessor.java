package org.opentestsystem.ap.imrt.iss.service.filter;

import org.opentestsystem.ap.imrt.common.model.BaseItem;
import org.opentestsystem.ap.imrt.iss.dto.search.Filter;
import org.opentestsystem.ap.imrt.iss.dto.search.IntegerRangeFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.MatchFilter;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Component;

import javax.persistence.criteria.Expression;
import java.util.Collection;
import java.util.Date;
import java.util.Optional;

/**
 * Handle processing filter options for {@link BaseItem}
 */
@Component
public class BaseItemFilterProcessor implements FilterProcessor<BaseItem> {
    @Override
    public Optional<Specification<BaseItem>> processFilter(Filter filter) {
        if (!FilterProperty.isSupportedFilterForProperty(filter)) {
            return Optional.empty();
        }

        /*
        Using instanceof here instead of adding the filter -> specification mapping
        to the Filter objects themselves.  The reason for doing it this way is our client
        facing objects are simple POJO's and do not know about the underlying data query
        implementation.
         */
        if (filter instanceof MatchFilter) {
            return process((MatchFilter) filter);
        } else if (filter instanceof IntegerRangeFilter) {
            return process((IntegerRangeFilter) filter);
        }

        //This means that a filter type is passed to this processor that is not handled.
        //This is most likely a coding issue and should be logged at the caller
        return Optional.empty();
    }

    private Optional<Specification<BaseItem>> process(MatchFilter matchFilter) {
        return Optional.of(isIn(getImrtFilterProperty(matchFilter), matchFilter.getValues()));
    }

    private Optional<Specification<BaseItem>> process(IntegerRangeFilter integerRangeFilter) {
        return Optional.of(isBetween(getImrtFilterProperty(integerRangeFilter),
                integerRangeFilter.getMin(),
                integerRangeFilter.getMax()));
    }

    private static Specification<BaseItem> isIn(final String field, final Collection<String> values) {
        return (root, query, cb) -> {
            Expression<String> exp = root.get(field);
            return exp.in(values);
        };
    }

    private static Specification<BaseItem> isBetween(final String field, final int minValue, final int maxValue) {
        return (root, query, cb) -> cb.between(root.get(field), minValue, maxValue);
    }

    private String getImrtFilterProperty(Filter filter) {
        return FilterProperty.getImrtSearchProperty(filter.getProperty())
                .orElseThrow(() -> new IllegalArgumentException(
                        String.format("Invalid property %s for filter type %s", filter.getProperty(), filter.getType()))
                );
    }
}

