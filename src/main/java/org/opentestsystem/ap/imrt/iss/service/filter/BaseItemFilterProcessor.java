package org.opentestsystem.ap.imrt.iss.service.filter;

import org.opentestsystem.ap.imrt.common.model.BaseItem;
import org.opentestsystem.ap.imrt.iss.dto.search.ContainsFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.Filter;
import org.opentestsystem.ap.imrt.iss.dto.search.IntegerRangeFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.MatchFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.NumberOfDaysRangeFilter;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Component;

import javax.persistence.criteria.Expression;
import javax.persistence.criteria.Predicate;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Collection;
import java.util.Locale;
import java.util.Optional;

/**
 * Handle processing filter options for {@link BaseItem}
 */
@Component
public class BaseItemFilterProcessor implements FilterProcessor<BaseItem> {
    @Override
    public Optional<Specification<BaseItem>> processFilter(Filter filter) {
        if (!FilterProperty.isSupportedFilterForProperty(filter)) {
            return Optional.empty();
        }

        /*
        Using instanceof here instead of adding the filter -> specification mapping
        to the Filter objects themselves.  The reason for doing it this way is our client
        facing objects are simple POJO's and do not know about the underlying data query
        implementation.
         */
        if (filter instanceof MatchFilter) {
            return process((MatchFilter) filter);
        } else if (filter instanceof NumberOfDaysRangeFilter) {
            return process((NumberOfDaysRangeFilter) filter);
        } else if (filter instanceof IntegerRangeFilter) {
            return process((IntegerRangeFilter) filter);
        } else if (filter instanceof ContainsFilter) {
            return process((ContainsFilter) filter);
        }

        //This means that a filter type is passed to this processor that is not handled.
        //This is most likely a coding issue and should be logged at the caller
        return Optional.empty();
    }

    private Optional<Specification<BaseItem>> process(MatchFilter matchFilter) {
        return Optional.of(isIn(getImrtFilterProperty(matchFilter), matchFilter.getValues()));
    }

    private Optional<Specification<BaseItem>> process(IntegerRangeFilter integerRangeFilter) {
        return Optional.of(isBetween(getImrtFilterProperty(integerRangeFilter),
                integerRangeFilter.getMin(),
                integerRangeFilter.getMax()));
    }

    /**
     * Process the {@link org.opentestsystem.ap.imrt.iss.dto.search.NumberOfDaysRangeFilter}.
     * <p>
     * If the min and max values are provided, then build a "half-open" BETWEEN criteria.  If only min is provided,
     * build a less-than criteria.
     * </p>
     *
     * @param numberOfDaysRangeFilter The {@link org.opentestsystem.ap.imrt.iss.dto.search.NumberOfDaysRangeFilter} being processed.
     * @return A {@link org.springframework.data.jpa.domain.Specification<org.opentestsystem.ap.imrt.common.model.BaseItem>}
     * with the appropriate criteria based on the filter's input.
     */
    private Optional<Specification<BaseItem>> process(final NumberOfDaysRangeFilter numberOfDaysRangeFilter) {
        if (numberOfDaysRangeFilter.getMax().isPresent()) {
            // Trim off the time; we're only interested in the date (mm/yy/dddd).
            final Instant oldestDate = Instant.now().minus(numberOfDaysRangeFilter.getMax().get(), ChronoUnit.DAYS)
                    .truncatedTo(ChronoUnit.DAYS);

            // Get the beginning of the next day _after_ the most recent date the caller is interested in.  The "min"
            // value here means "minimum number fo day(s)", so we need to decrement min by 1 to get the beginning of the
            // next day _after_ the most recent date.  E.g. if today is 10apr18 and we want everything between 5 and 10
            // days old, the query is "WHERE date_field >= 01apr18 AND date_field < 06apr18.
            // Trim off the time; we're only interested in the date (mm/yy/dddd).
            final Instant mostRecentDate =
                    Instant.now().minus(numberOfDaysRangeFilter.getMin() - 1, ChronoUnit.DAYS)
                            .truncatedTo(ChronoUnit.DAYS);

            return Optional.of(isBetweenHalfOpen(getImrtFilterProperty(numberOfDaysRangeFilter),
                    Instant.from(oldestDate),
                    Instant.from(mostRecentDate)));
        } else {
            // Get everything less than the beginning of the next day.  E.g. if today is 10apr18 and we want everything
            // five days old or older, then the query is "WHERE date_field < 06par18 00:00:00.000".
            final Instant cutOffDate = Instant.now().minus(numberOfDaysRangeFilter.getMin() - 1, ChronoUnit.DAYS)
                    .truncatedTo(ChronoUnit.DAYS);
            return Optional.of(isLessThan(getImrtFilterProperty(numberOfDaysRangeFilter), cutOffDate));
        }
    }

    /**
     * Process the {@link org.opentestsystem.ap.imrt.iss.dto.search.ContainsFilter}.
     *
     * @param containsFilter The {@link org.opentestsystem.ap.imrt.iss.dto.search.ContainsFilter} to process.
     * @return A {@link org.springframework.data.jpa.domain.Specification<org.opentestsystem.ap.imrt.common.model.BaseItem>}
     * with the appropriate criteria based on the filter's input.
     */
    private Optional<Specification<BaseItem>> process(final ContainsFilter containsFilter) {
        return Optional.of(contains(getImrtFilterProperty(containsFilter), containsFilter.getValue()));
    }

    /**
     * A {@link org.springframework.data.jpa.domain.Specification} for specifying a group of values as criteria.
     * <p>
     * This will emit an IN criteria to the SQL generated by JPA.
     * </p>
     *
     * @param field  The database field that is the subject of this criteria
     * @param values The collection of values to include in the IN clause
     * @return A {@link org.springframework.data.jpa.domain.Specification<org.opentestsystem.ap.imrt.common.model.BaseItem>}
     * * with the appropriate criteria based on the filter's input.
     */
    private static Specification<BaseItem> isIn(final String field, final Collection<String> values) {
        return (root, query, cb) -> {
            Expression<String> exp = root.get(field);
            return exp.in(values);
        };
    }

    /**
     * A {@link org.springframework.data.jpa.domain.Specification} for an inclusive between for a range of
     * integer/number values.
     * <p>
     * This will emit BETWEEN criteria to the SQL generated by JPA.  For example, if the request is "show me all
     * the records between 1 and 10", both 1 and 10 will be included in the result set.
     * </p>
     *
     * @param field    The database field that is the subject of this criteria
     * @param minValue The minimum value of the BETWEEN statement
     * @param maxValue The maximum value of the BETWEEN statement
     * @return A {@link org.springframework.data.jpa.domain.Specification<org.opentestsystem.ap.imrt.common.model.BaseItem>}
     * with the appropriate criteria based on the filter's input.
     */
    private static Specification<BaseItem> isBetween(final String field, final int minValue, final int maxValue) {
        return (root, query, cb) -> cb.between(root.get(field), minValue, maxValue);
    }

    /**
     * A {@link org.springframework.data.jpa.domain.Specification} for "half open" implementation for fetching records
     * between two {@link java.time.Instant}s.
     * <p>
     * This will emit "date_field >= [my minimum date] AND date_field < [may maximum date]" to the SQL generated by JPA.
     * </p>
     *
     * @param field   field The database field that is the subject of this criteria
     * @param minDate The minimum value as the operand for the greater-than-or-equal-to half of the comparison
     * @param maxDate The maximum value as the operand for the less-than half of the comparison
     * @return A {@link org.springframework.data.jpa.domain.Specification<org.opentestsystem.ap.imrt.common.model.BaseItem>}
     * * with the appropriate criteria based on the filter's input.
     */
    private static Specification<BaseItem> isBetweenHalfOpen(final String field,
                                                             final Instant minDate,
                                                             final Instant maxDate) {
        return (root, query, cb) -> {
            final Predicate greaterThanOrEqualToPredicate = cb.greaterThanOrEqualTo(root.get(field), minDate);
            final Predicate lessThanPredicate = cb.lessThan(root.get(field), maxDate);
            return cb.and(greaterThanOrEqualToPredicate, lessThanPredicate);
        };
    }

    /**
     * A "less than" {@link org.springframework.data.jpa.domain.Specification} for fetching all records less than a
     * {@link java.time.Instant}.
     *
     * @param field   field The database field that is the subject of this criteria
     * @param minDate The minimum value as the operand for the greater-than-or-equal-to comparison
     * @return A {@link org.springframework.data.jpa.domain.Specification<org.opentestsystem.ap.imrt.common.model.BaseItem>}
     * with the appropriate criteria based on the filter's input.
     */
    private static Specification<BaseItem> isLessThan(final String field, final Instant minDate) {
        return (root, query, cb) -> cb.lessThan(root.get(field), minDate);
    }

    /**
     * A case-insensitive filter for fetching all records that have a string that containing the desired value.
     * <p>
     * This will emit a "LIKE '%value%'" clause to the SQL generated by JPA.  The case-insensitivity is handled by
     * setting the field queried and the value to lower-case.
     * </p>
     *
     * @param field field The database field that is the subject of this criteria
     * @param value The string fragment to filter by
     * @return A {@link org.springframework.data.jpa.domain.Specification<org.opentestsystem.ap.imrt.common.model.BaseItem>}
     * with the appropriate criteria based on the filter's input.
     */
    private static Specification<BaseItem> contains(final String field, final String value) {
        return (root, query, cb) ->
                cb.like(cb.lower(root.get(field)), "%" + value.toLowerCase(Locale.ROOT) + "%");
    }

    /**
     * Fetch the name of the property the {@link org.opentestsystem.ap.imrt.iss.dto.search.Filter} should be applied to.
     *
     * @param filter The {@link org.opentestsystem.ap.imrt.iss.dto.search.Filter} being inspected.
     * @return The name of the property to which the {@link org.opentestsystem.ap.imrt.iss.dto.search.Filter} applies.
     */
    private String getImrtFilterProperty(Filter filter) {
        return FilterProperty.getImrtSearchProperty(filter.getProperty())
                .orElseThrow(() -> new IllegalArgumentException(
                        String.format("Invalid property %s for filter type %s", filter.getProperty(), filter.getType()))
                );
    }
}

