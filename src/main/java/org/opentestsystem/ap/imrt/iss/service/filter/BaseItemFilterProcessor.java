package org.opentestsystem.ap.imrt.iss.service.filter;

import org.opentestsystem.ap.imrt.common.model.BaseItem;
import org.opentestsystem.ap.imrt.iss.dto.search.Filter;
import org.opentestsystem.ap.imrt.iss.dto.search.IntegerRangeFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.MatchFilter;
import org.springframework.data.jpa.domain.Specification;

import javax.persistence.criteria.Expression;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

public class BaseItemFilterProcessor {
    private static final Map<String,String> FILTER_TO_FIElDS;
    static {
        Map<String, String> filterToFields = new HashMap<>();
        filterToFields.put("itemId", "itemId");
        filterToFields.put("grade", "grade");
        filterToFields.put("stimulusId", "associatedStimulusId");
        filterToFields.put("depthOfKnowledge", "depthOfKnowledge");
        filterToFields.put("workflowStatus", "workflowStatus");
        filterToFields.put("itemType", "itemType");

        FILTER_TO_FIElDS = Collections.unmodifiableMap(filterToFields);
    }

    public Optional<Specification<BaseItem>> processFilter(Filter filter) {
        if(!FILTER_TO_FIElDS.containsKey(filter.getProperty())) {
           return Optional.empty();
        }

        if(filter instanceof MatchFilter) {
            return process((MatchFilter) filter);
        } else if (filter instanceof  IntegerRangeFilter) {
            return process((IntegerRangeFilter) filter);
        }

        //It will be rare occurrence
        return Optional.empty();
    }

    private Optional<Specification<BaseItem>> process(MatchFilter matchFilter) {
        return Optional.of(isIn(matchFilter.getProperty(), matchFilter.getValues()));
    }

    private Optional<Specification<BaseItem>> process(IntegerRangeFilter integerRangeFilter){
        return Optional.empty();
    }

    private static Specification<BaseItem> isIn(final String field, final Collection<String> values) {
        return (root, query, cb) -> {
            Expression<String> exp = root.get(field);
            return exp.in(values);
        };
    }
}

