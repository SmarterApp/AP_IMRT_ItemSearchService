package org.opentestsystem.ap.imrt.iss.service.filter;

import org.opentestsystem.ap.imrt.common.model.BaseItem;
import org.opentestsystem.ap.imrt.iss.dto.search.Filter;
import org.opentestsystem.ap.imrt.iss.dto.search.IntegerRangeFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.MatchFilter;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Component;

import javax.persistence.criteria.Expression;
import javax.persistence.criteria.Predicate;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Collection;
import java.util.Optional;

/**
 * Handle processing filter options for {@link BaseItem}
 */
@Component
public class BaseItemFilterProcessor implements FilterProcessor<BaseItem> {
    @Override
    public Optional<Specification<BaseItem>> processFilter(Filter filter) {
        if (!FilterProperty.isSupportedFilterForProperty(filter)) {
            return Optional.empty();
        }

        /*
        Using instanceof here instead of adding the filter -> specification mapping
        to the Filter objects themselves.  The reason for doing it this way is our client
        facing objects are simple POJO's and do not know about the underlying data query
        implementation.
         */
        if (filter instanceof MatchFilter) {
            return process((MatchFilter) filter);
        } else if (filter instanceof IntegerRangeFilter) {
            return process((IntegerRangeFilter) filter);
        }

        //This means that a filter type is passed to this processor that is not handled.
        //This is most likely a coding issue and should be logged at the caller
        return Optional.empty();
    }

    private Optional<Specification<BaseItem>> process(MatchFilter matchFilter) {
        return Optional.of(isIn(getImrtFilterProperty(matchFilter), matchFilter.getValues()));
    }

    private Optional<Specification<BaseItem>> process(IntegerRangeFilter integerRangeFilter) {
        if (integerRangeFilter.getUnit().equals("days")) {
            final Instant oldestDate = Instant.now().minus(integerRangeFilter.getMax(), ChronoUnit.DAYS)
                    .truncatedTo(ChronoUnit.DAYS);

            if (integerRangeFilter.getMin() != null) {
                final Instant mostRecentDate =
                        Instant.now().minus(integerRangeFilter.getMin() - 1, ChronoUnit.DAYS)
                                .truncatedTo(ChronoUnit.DAYS);

                return Optional.of(isBetweenHalfOpen(getImrtFilterProperty(integerRangeFilter),
                        Instant.from(oldestDate),
                        Instant.from(mostRecentDate)));
            } else {
                return Optional.of(isGreaterThanOrEqualTo(getImrtFilterProperty(integerRangeFilter), oldestDate));
            }
        }

        return Optional.of(isBetween(getImrtFilterProperty(integerRangeFilter),
                integerRangeFilter.getMin(),
                integerRangeFilter.getMax()));
    }

    private static Specification<BaseItem> isIn(final String field, final Collection<String> values) {
        return (root, query, cb) -> {
            Expression<String> exp = root.get(field);
            return exp.in(values);
        };
    }

    /**
     * An inclusive between for a range of integer/number values.
     * <p>
     * This will add BETWEEN criteria to the SQL generated by JPA.  For example, if the request is "show me all
     * the records between 1 and 10
     * </p>
     *
     * @param field
     * @param minValue
     * @param maxValue
     * @return
     */
    private static Specification<BaseItem> isBetween(final String field, final int minValue, final int maxValue) {
        return (root, query, cb) -> cb.between(root.get(field), minValue, maxValue);
    }

    private static Specification<BaseItem> isBetweenHalfOpen(final String field,
                                                             final Instant minDate,
                                                             final Instant maxDate) {
        return (root, query, cb) -> {
            final Predicate greaterThanOrEqualToPredicate = cb.greaterThanOrEqualTo(root.get(field), minDate);
            final Predicate lessThanPredicate = cb.lessThan(root.get(field), maxDate);
            return cb.and(greaterThanOrEqualToPredicate, lessThanPredicate);
        };
    }

    private static Specification<BaseItem> isGreaterThanOrEqualTo(final String field, final Instant minDate) {
        return (root, query, cb) -> cb.greaterThanOrEqualTo(root.get(field), minDate);
    }

    private String getImrtFilterProperty(Filter filter) {
        return FilterProperty.getImrtSearchProperty(filter.getProperty())
                .orElseThrow(() -> new IllegalArgumentException(
                        String.format("Invalid property %s for filter type %s", filter.getProperty(), filter.getType()))
                );
    }
}

