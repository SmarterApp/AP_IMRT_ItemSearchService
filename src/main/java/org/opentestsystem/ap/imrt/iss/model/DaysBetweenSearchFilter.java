package org.opentestsystem.ap.imrt.iss.model;

import com.google.common.annotations.VisibleForTesting;
import org.opentestsystem.ap.imrt.common.model.BaseItem;
import org.springframework.data.jpa.domain.Specification;

import java.time.Instant;
import java.time.temporal.ChronoUnit;

import static org.opentestsystem.ap.imrt.iss.service.filter.BaseItemFilterSpecifications.isBetweenHalfOpen;
import static org.opentestsystem.ap.imrt.iss.service.filter.BaseItemFilterSpecifications.isGreaterThanOrEqualTo;
import static org.opentestsystem.ap.imrt.iss.service.filter.BaseItemFilterSpecifications.isLessThan;

/**
 * Handles filters that find values between days.  for example, find items that have been in a status for 1 to 5 days
 */
public class DaysBetweenSearchFilter extends AbstractSearchFilter implements SearchFilter {
    private final Integer min;
    private final Integer max;

    public DaysBetweenSearchFilter(final String filterProperty, final Integer min, final Integer max) {
        super(filterProperty);
        this.min = min;
        this.max = max;
    }

    @Override
    public boolean isEmpty() {
        return min == null && max == null;
    }

    @Override
    public boolean isValid() {
        return true;
    }

    @Override
    public Specification<BaseItem> getSpecification() {
        if (max != null && min != null) {
            // Trim off the time; we're only interested in the date (mm/yy/dddd).
            final Instant oldestDate = Instant.now().minus(max, ChronoUnit.DAYS)
                    .truncatedTo(ChronoUnit.DAYS);

            // Get the beginning of the next day _after_ the most recent date the caller is interested in.  The "min"
            // value here means "minimum number fo day(s)", so we need to decrement min by 1 to get the beginning of the
            // next day _after_ the most recent date.  E.g. if today is 10apr18 and we want everything between 5 and 10
            // days old, the query is "WHERE date_field >= 01apr18 AND date_field < 06apr18.
            // Trim off the time; we're only interested in the date (mm/yy/dddd).
            final Instant mostRecentDate =
                    Instant.now().minus(min - 1, ChronoUnit.DAYS)
                            .truncatedTo(ChronoUnit.DAYS);

            return isBetweenHalfOpen(getFilterProperty().getProperty(),
                    Instant.from(oldestDate),
                    Instant.from(mostRecentDate));
        } else if (min != null) {
            // Get everything less than the beginning of the next day.  E.g. if today is 10apr18 and we want everything
            // five days old or older, then the query is "WHERE date_field < 06par18 00:00:00.000".
            final Instant cutOffDate = Instant.now().minus(min - 1, ChronoUnit.DAYS)
                    .truncatedTo(ChronoUnit.DAYS);
            return isLessThan(getFilterProperty().getProperty(), cutOffDate);
        } else {
            // Trim off the time; we're only interested in the date (mm/yy/dddd).
            final Instant cutOffDate = Instant.now().minus(max, ChronoUnit.DAYS)
                    .truncatedTo(ChronoUnit.DAYS);
            return isGreaterThanOrEqualTo(getFilterProperty().getProperty(), Instant.from(cutOffDate));
        }
    }

    @VisibleForTesting
    Integer getMin() {
        return min;
    }

    @VisibleForTesting
    Integer getMax() {
        return max;
    }

    @Override
    public FilterQuery getFilterQuery() {
        return null;
    }
}
