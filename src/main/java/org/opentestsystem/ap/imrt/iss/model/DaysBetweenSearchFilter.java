package org.opentestsystem.ap.imrt.iss.model;

import com.google.common.annotations.VisibleForTesting;
import org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty;

import java.sql.Timestamp;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.HashMap;
import java.util.Map;

/**
 * Handles filters that find values between days.  for example, find items that have been in a status for 1 to 5 days
 */
public class DaysBetweenSearchFilter extends AbstractSearchFilter implements SearchFilter {
    private final Integer min;
    private final Integer max;

    public DaysBetweenSearchFilter(final SearchProperty filterProperty, final Integer min, final Integer max) {
        super(filterProperty);
        this.min = min;
        this.max = max;
    }

    @Override
    public boolean isEmpty() {
        return min == null && max == null;
    }

    @Override
    public boolean isValid() {
        return true;
    }

    @VisibleForTesting
    Integer getMin() {
        return min;
    }

    @VisibleForTesting
    Integer getMax() {
        return max;
    }

    @Override
    public FilterQuery getFilterQuery() {
        Map<String, Object> parameters = new HashMap<>();
        String sql;

        String minParameter = getFilterProperty().getProperty() + "Min";
        String maxParameter = getFilterProperty().getProperty() + "Max";

        if (max != null && min != null) {
            // Trim off the time; we're only interested in the date (mm/yy/dddd).
            final Instant oldestDate = Instant.now().minus(max, ChronoUnit.DAYS)
                    .truncatedTo(ChronoUnit.DAYS);

            // Get the beginning of the next day _after_ the most recent date the caller is interested in.  The "min"
            // value here means "minimum number fo day(s)", so we need to decrement min by 1 to get the beginning of the
            // next day _after_ the most recent date.  E.g. if today is 10apr18 and we want everything between 5 and 10
            // days old, the query is "WHERE date_field >= 01apr18 AND date_field < 06apr18.
            // Trim off the time; we're only interested in the date (mm/yy/dddd).
            final Instant mostRecentDate =
                    Instant.now().minus(min - 1, ChronoUnit.DAYS)
                            .truncatedTo(ChronoUnit.DAYS);

            sql = getFilterProperty().getColumnName() + " >= :" + minParameter + " AND " + getFilterProperty().getColumnName() + "< :" + maxParameter;
            parameters.put(minParameter, Timestamp.from(oldestDate));
            parameters.put(maxParameter, Timestamp.from(mostRecentDate));
        } else if (min != null) {
            // Get everything less than the beginning of the next day.  E.g. if today is 10apr18 and we want everything
            // five days old or older, then the query is "WHERE date_field < 06par18 00:00:00.000".
            final Instant cutOffDate = Instant.now().minus(min - 1, ChronoUnit.DAYS)
                    .truncatedTo(ChronoUnit.DAYS);

            sql = getFilterProperty().getColumnName() + " < :" + minParameter;
            parameters.put(minParameter, Timestamp.from(cutOffDate));
        } else {
            // Trim off the time; we're only interested in the date (mm/yy/dddd).
            final Instant cutOffDate = Instant.now().minus(max, ChronoUnit.DAYS)
                    .truncatedTo(ChronoUnit.DAYS);

            sql = getFilterProperty().getColumnName() + " >= :" + maxParameter;
            parameters.put(maxParameter, Timestamp.from(cutOffDate));
        }

        return new FilterQuery(sql, parameters);
    }
}
