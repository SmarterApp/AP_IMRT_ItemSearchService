package org.opentestsystem.ap.imrt.iss.core.keyword;

import org.apache.commons.lang.RandomStringUtils;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.ap.imrt.iss.config.ItemSearchServiceProperties;
import org.opentestsystem.ap.imrt.iss.core.keyword.KeywordResultsHighlighter;

import java.util.Arrays;
import java.util.List;

import static java.util.stream.Collectors.toList;
import static org.hamcrest.CoreMatchers.either;
import static org.hamcrest.CoreMatchers.startsWith;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.endsWith;
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.isEmptyString;
import static org.hamcrest.Matchers.lessThanOrEqualTo;
import static org.hamcrest.Matchers.not;
import static org.mockito.Mockito.when;
import static org.opentestsystem.ap.imrt.iss.core.keyword.KeywordSearchToRegexEvaluator.AND_SYMBOL;
import static org.opentestsystem.ap.imrt.iss.core.keyword.KeywordSearchToRegexEvaluator.MULTI_WILDCARD;
import static org.opentestsystem.ap.imrt.iss.core.keyword.KeywordSearchToRegexEvaluator.NEGATE_SYMBOL;
import static org.opentestsystem.ap.imrt.iss.core.keyword.KeywordSearchToRegexEvaluator.OR_SYMBOL;
import static org.opentestsystem.ap.imrt.iss.core.keyword.KeywordSearchToRegexEvaluator.SINGLE_WILDCARD;

@RunWith(MockitoJUnitRunner.class)
public class KeywordResultsHighlighterTest {
    private KeywordResultsHighlighter highlighter;
    private static int MAX_HIGHLIGHT = 50;

    @Mock
    private ItemSearchServiceProperties properties;

    @Before
    public void setUp() {
        when(properties.getMaxKeywordContextLength()).thenReturn(MAX_HIGHLIGHT);
        highlighter = new KeywordResultsHighlighter(properties);
    }

    @Test
    public void shouldFindSingleWord() {
        final String searchExpression = "good";
        final boolean caseSensitive = false;
        final List<String> contents = Arrays.asList(
                "Now is the time for all good men and women to come to aid of their country.",
                "Working for the public good should be the top priority of all men and women");

        final List<String> highlights = contents
                .stream()
                .map(c -> highlighter.highlight(searchExpression, caseSensitive, c))
                .collect(toList());

        assertThat(highlights.get(0), containsString("good"));
        assertThat(highlights.get(1), containsString("good"));
    }

    @Test
    public void shouldFindConsecutiveWords() {
        final String searchExpression = "good men";
        final boolean caseSensitive = false;
        final List<String> contents = Arrays.asList(
                "Now is the time for all good men and women to come to aid of their country.",
                "Working for the public good should be the top priority of all men and women");

        final List<String> highlights = contents
                .stream()
                .map(c -> highlighter.highlight(searchExpression, caseSensitive, c))
                .collect(toList());

        // match consecutive words only
        assertThat(highlights.get(0), containsString("good men"));
        assertThat(highlights.get(1), isEmptyString());
    }

    @Test
    public void shouldAllowCaseSensitiveMatches() {
        final String searchExpression = "jack";
        final boolean caseSensitive = true;
        final List<String> contents = Arrays.asList(
                "Jack and Jill went up the hill to play a game of poker.",
                "Jack had a pair of queens and thought he would win, but Jill had three jacks.");

        final List<String> highlights = contents
                .stream()
                .map(c -> highlighter.highlight(searchExpression, caseSensitive, c))
                .collect(toList());

        assertThat(highlights.get(0), isEmptyString());
        assertThat(highlights.get(1), containsString("jack"));

        // The following is true only because the added context does not extend as far as the word Jack.
        // If the max highlight value is tuned higher, this could fail.
        assertThat(highlights.get(1), not(containsString("Jack")));
    }

    @Test
    public void shouldAllowSingleQuotesInSearch() {
        final String searchExpression = "man's";
        final boolean caseSensitive = false;
        final List<String> contents = Arrays.asList(
                "A dog is man's best friend.");

        final List<String> highlights = contents
                .stream()
                .map(c -> highlighter.highlight(searchExpression, caseSensitive, c))
                .collect(toList());

        assertThat(highlights.get(0), containsString("man's"));
    }

    @Test
    public void shouldTreatDoubledDoubleQuotesAsEscapedQuotes() {
        final String searchExpression = "\"\"Early to bed";
        final boolean caseSensitive = false;
        final List<String> contents = Arrays.asList(
                "Benjamin Franklin said, \"Early to bed, early to rise ...\"");

        final List<String> highlights = contents
                .stream()
                .map(c -> highlighter.highlight(searchExpression, caseSensitive, c))
                .collect(toList());

        assertThat(highlights.get(0), containsString("\"Early to bed"));
    }

    @Test
    public void shouldAllowLogicalAndExpression() {
        final String searchExpression = "good " + AND_SYMBOL + " men";
        final boolean caseSensitive = false;
        final List<String> contents = Arrays.asList(
                "Now is the time for all good men and women to come to aid of their country.",
                "Working for the public good should be the top priority of all men and women");

        final List<String> highlights = contents
                .stream()
                .map(c -> highlighter.highlight(searchExpression, caseSensitive, c))
                .collect(toList());

        assertThat(highlights.get(0), containsString("good men"));
        assertThat(highlights.get(1), containsString("good"));
        assertThat(highlights.get(1).length(), is(lessThanOrEqualTo(MAX_HIGHLIGHT)));
    }

    @Test
    public void shouldAllowLogicalOrExpressions() {
        final String searchExpression = "good " + OR_SYMBOL + " working";
        final boolean caseSensitive = false;
        final List<String> contents = Arrays.asList(
                "Now is the time for all good men and women to come to aid of their country.",
                "Working for the public good should be the top priority of all men and women");

        final List<String> highlights = contents
                .stream()
                .map(c -> highlighter.highlight(searchExpression, caseSensitive, c))
                .collect(toList());

        assertThat(highlights.get(0), containsString("good"));
        assertThat(highlights.get(1),
                either(containsString("Working")).or(containsString("good")));
    }

    @Test
    public void shouldAllowLogicalNotExpressions() {
        final String searchExpression = NEGATE_SYMBOL + "working";
        final boolean caseSensitive = false;
        final List<String> contents = Arrays.asList(
                "Now is the time for all good men and women to come to aid of their country.",
                "Working for the public good should be the top priority of all men and women");

        final List<String> highlights = contents
                .stream()
                .map(c -> highlighter.highlight(searchExpression, caseSensitive, c))
                .collect(toList());

        assertThat(highlights.get(0), startsWith("Now is the time"));
        assertThat(highlights.get(0).length(), is(lessThanOrEqualTo(MAX_HIGHLIGHT)));
        assertThat(highlights.get(1), isEmptyString());
    }

    @Test
    public void shouldAllowComplexLogicalExpressions() {
        final String searchExpression = "{good " + OR_SYMBOL + " bad} " + AND_SYMBOL + " " + NEGATE_SYMBOL + "working";
        final boolean caseSensitive = false;
        final List<String> contents = Arrays.asList(
                "Now is the time for all good men and women to come to aid of their country.",
                "Working for the public good should be the top priority of all men and women",
                "Bad news is a headline, and gradual improvement is not.");

        final List<String> highlights = contents
                .stream()
                .map(c -> highlighter.highlight(searchExpression, caseSensitive, c))
                .collect(toList());

        assertThat(highlights.get(0), containsString("good"));
        assertThat(highlights.get(1), isEmptyString());
        assertThat(highlights.get(2), containsString("Bad"));
    }

    @Test
    public void shouldFindSingleWildcard() {
        final String searchExpression = "te" + SINGLE_WILDCARD + "t";
        final boolean caseSensitive = false;
        final List<String> contents = Arrays.asList(
                "Here is some text to search.",
                "The students all said the test was hard but fair",
                "Today, 'termagant' is considered a sexist word.",
                "The Vietnamese new year is called Tet Nguyen Dan");

        final List<String> highlights = contents
                .stream()
                .map(c -> highlighter.highlight(searchExpression, caseSensitive, c))
                .collect(toList());

        assertThat(highlights.get(0), containsString("text"));
        assertThat(highlights.get(1), containsString("test"));
        assertThat(highlights.get(2), isEmptyString());
        assertThat(highlights.get(3), isEmptyString());
    }

    @Test
    public void shouldFindMultiWildcard() {
        final String searchExpression = "te" + MULTI_WILDCARD + "t";
        final boolean caseSensitive = false;
        final List<String> contents = Arrays.asList(
                "Here is some text to search.",
                "The students all said the test was hard but fair",
                "Today, 'termagant' is considered a sexist word.",
                "The Vietnamese new year is called Tet Nguyen Dan");

        final List<String> highlights = contents
                .stream()
                .map(c -> highlighter.highlight(searchExpression, caseSensitive, c))
                .collect(toList());

        assertThat(highlights.get(0), containsString("text"));
        assertThat(highlights.get(1), containsString("test"));
        assertThat(highlights.get(2), containsString("termagant"));
        assertThat(highlights.get(3), containsString("Tet"));
    }

    @Test
    public void shouldFindQuotedString() {
        final String searchExpression = "\"" + AND_SYMBOL + ", " + OR_SYMBOL + ", " + NEGATE_SYMBOL +
                ", {, }, " + SINGLE_WILDCARD + ", and " + MULTI_WILDCARD + " should be escaped when inside " +
                "a quoted string\"";
        final boolean caseSensitive = false;
        final List<String> contents = Arrays.asList(searchExpression);

        final List<String> highlights = contents
                .stream()
                .map(c -> highlighter.highlight(searchExpression, caseSensitive, c))
                .collect(toList());

        assertThat(highlights.get(0), containsString("" + AND_SYMBOL + ", " + OR_SYMBOL +
                ", " + NEGATE_SYMBOL + ", {, }, " + SINGLE_WILDCARD + ", and " + MULTI_WILDCARD));
    }

    @Test
    public void shouldAddContextToMatchRegion() {
        final String searchExpression = "my text";
        final boolean caseSensitive = false;

        // Context highlights may be trimmed, so replace whitespace here to test for exactly MAX_HIGHLIGHT chars.
        final List<String> contents = Arrays.asList(
                "Lorem.ipsum.dolor.sit.amet,.consectetur.adipiscing.my text.elit..Aenean.venenatis.rutrum.sem,.interdum.amet",
                "my text Lorem.ipsum.dolor.sit.amet,.consectetur.adipiscing.elit..Aenean.venenatis.rutrum.sem,.interdum.amet",
                "Lorem.ipsum.dolor.sit.amet,.consectetur.adipiscing.elit..Aenean.venenatis.rutrum.sem,.interdum.amet my text");

        final List<String> highlights = contents
                .stream()
                .map(c -> highlighter.highlight(searchExpression, caseSensitive, c))
                .collect(toList());

        // Context padding should go on both sides when match is in the middle of the content.
        assertThat(highlights.get(0), containsString("my text"));
        assertThat(highlights.get(0), not(startsWith("my text")));
        assertThat(highlights.get(0), not(endsWith("my text")));
        assertThat(highlights.get(0).length(), equalTo(MAX_HIGHLIGHT));

        // Context padding should go on right when match at the beginning of the content.
        assertThat(highlights.get(1), containsString("my text"));
        assertThat(highlights.get(1), startsWith("my text"));
        assertThat(highlights.get(1).length(), equalTo(MAX_HIGHLIGHT));

        // Context padding should go on right when match at the beginning of the content.
        assertThat(highlights.get(2), containsString("my text"));
        assertThat(highlights.get(2), endsWith("my text"));
        assertThat(highlights.get(2).length(), equalTo(MAX_HIGHLIGHT));
    }

    @Test
    public void shouldPreferPaddingContextOnLeft() {
        final String searchExpression = RandomStringUtils.random(MAX_HIGHLIGHT - 5, true, false);
        final boolean caseSensitive = true;

        // Context highlights may be trimmed, so replace whitespace here to test for exactly MAX_HIGHLIGHT chars.
        final List<String> contents = Arrays.asList(
                "Lorem.ipsum.dolor.sit.amet." + searchExpression + "consectetur.adipiscing.elit.");

        final List<String> highlights = contents
                .stream()
                .map(c -> highlighter.highlight(searchExpression, caseSensitive, c))
                .collect(toList());

        assertThat(highlights.get(0), endsWith(searchExpression));
        assertThat(highlights.get(0).length(), equalTo(MAX_HIGHLIGHT));
    }
}