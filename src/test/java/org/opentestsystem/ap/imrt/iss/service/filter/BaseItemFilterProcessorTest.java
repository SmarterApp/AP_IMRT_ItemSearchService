package org.opentestsystem.ap.imrt.iss.service.filter;

import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.ap.imrt.common.service.OperationalEventService;
import org.opentestsystem.ap.imrt.iss.dto.search.DateRangeFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.Filter;
import org.opentestsystem.ap.imrt.iss.dto.search.MatchFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.NumberOfDaysRangeFilter;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Collections;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.DAYS_IN_WORKFLOW_STATUS;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.ITEM_TYPE;

public class BaseItemFilterProcessorTest {
    private BaseItemFilterProcessor processor;

    @Before
    public void setUp() {
        processor = new BaseItemFilterProcessor(mock(OperationalEventService.class));
    }

    @Test
    public void shouldReturnEmptyForUnknownProperties() {
        MatchFilter matchFilter = new MatchFilter("bogus", Collections.singletonList("something"));

        assertThat(processor.processFilter(matchFilter)).isNotPresent();
    }

    @Test
    public void shouldReturnMatchSpecification() {
        MatchFilter matchFilter = new MatchFilter(ITEM_TYPE, Collections.singletonList("eq"));

        assertThat(processor.processFilter(matchFilter)).isPresent();
    }

    @Test
    public void shouldReturnNumberRangeSpecification() {
        MatchFilter matchFilter = new MatchFilter(ITEM_TYPE, Collections.singletonList("eq"));

        assertThat(processor.processFilter(matchFilter)).isPresent();
    }

    /**
     * When min and max are passed in a between half-open filter specification is returned
     */
    @Test
    public void shouldReturnDaysRangeBetweenSpecification() {
        NumberOfDaysRangeFilter numberOfDaysRangeFilter = new NumberOfDaysRangeFilter(DAYS_IN_WORKFLOW_STATUS, 1, 5);

        assertThat(processor.processFilter(numberOfDaysRangeFilter)).isPresent();
    }

    /**
     * When min is null and max is passed in, a greater-than-or-equal-to specification is returned.
     */
    @Test
    public void shouldReturnDaysRangeGreaterThanOrEqualToSpecification() {
        NumberOfDaysRangeFilter numberOfDaysRangeFilter = new NumberOfDaysRangeFilter(DAYS_IN_WORKFLOW_STATUS, 5, null);

        assertThat(processor.processFilter(numberOfDaysRangeFilter)).isPresent();
    }

    @Test
    public void shouldReturnGreaterThanOrEqualToDateRangeFilterSpecificationWhenFromDateIsSet() {
        final DateRangeFilter greaterThanOrEqualToDateFilter = new DateRangeFilter("createDate",
                null,
                Instant.now().minus(100, ChronoUnit.DAYS));

        assertThat(processor.processFilter(greaterThanOrEqualToDateFilter)).isPresent();
    }

    @Test
    public void shouldReturnLessThanOrEqualToDateRangeFilterSpecificationWhenToDateIsSet() {
        final DateRangeFilter lessThanOrEqualToDateFilter = new DateRangeFilter("createDate",
                Instant.now().plus(100, ChronoUnit.DAYS),
                null);

        assertThat(processor.processFilter(lessThanOrEqualToDateFilter)).isPresent();
    }

    @Test
    public void shouldReturnBetweenDateRangeFilterSpecificationWhenFromAndToDateAreSet() {
        final DateRangeFilter betweenDatesFilter = new DateRangeFilter("createDate",
                Instant.now().minus(100, ChronoUnit.DAYS),
                Instant.now().plus(100, ChronoUnit.DAYS));

        assertThat(processor.processFilter(betweenDatesFilter)).isPresent();
    }

    @Test
    public void shouldReturnEmptyDateRangeSpecificationWhenNeitherDateIsSet() {
        final DateRangeFilter emptyDateRangeFilter = new DateRangeFilter("createDate", null, null);

        assertThat(processor.processFilter(emptyDateRangeFilter)).isNotPresent();
    }

    @Test
    public void shouldReturnEmptyForUnknownFilter() {
        Filter filter = mock(Filter.class);

        assertThat(processor.processFilter(filter)).isNotPresent();
    }
}