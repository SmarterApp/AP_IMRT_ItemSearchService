package org.opentestsystem.ap.imrt.iss.model;

import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.ap.imrt.iss.dto.search.BooleanFlagFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.ContainsFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.DateRangeFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.IntegerRangeFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.KeywordFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.MatchFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import static org.assertj.core.api.Assertions.assertThat;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ALLOW_CALCULATOR;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ASL_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ASL_REQUIRED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ASL_UPLOADED_PRIOR_TO_LAST_CONTENT_UPDATE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ASSESSMENT_TYPE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ASSIGNED_BY;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ASSIGNED_DATES;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ASSIGNEES;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ASSOCIATED_ITEM_COUNT;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.BEING_CREATED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.BRAILLE_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.BRAILLE_REQUIRED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.BRAILLE_UPLOADED_PRIOR_TO_LAST_CONTENT_UPDATE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.CALCULATED_EXPOSURES_COUNT;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.CALCULATED_FORM_COUNT;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.CC_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.CC_REQUIRED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.CLOSED_CAPTIONING_UPLOADED_PRIOR_TO_LAST_CONTENT_UPDATE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.CONTENT_CHANGED_AFTER_OPERATIONAL;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.CONTENT_TASK_MODEL;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.CREATED_BY;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.CREATE_DATE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.CURRENT_UPDATE_NEED_CREATED_DATE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.CURRENT_UPDATE_NEED_INTERNAL_RESOLUTION;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.CURRENT_UPDATE_NEED_INTERNAL_RESOLUTION_DATE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.CURRENT_UPDATE_NEED_RESOLUTION;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.CURRENT_UPDATE_NEED_RESOLUTION_DATE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.DAYS_IN_WORKFLOW_STATUS;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.DOK;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ENGLISH_CONTENT_LAST_UPDATED_DATE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ENGLISH_GLOSSARY_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ENGLISH_PASSAGES_COUNT;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.FORM_TYPE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.GRADE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.HAS_UNRESOLVED_UPDATE_NEED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ILLUSTRATED_GLOSSARY_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ILLUSTRATED_GLOSSARY_REQUIRED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ITEM_AUTHOR;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ITEM_DIFFICULTY_QUINTILE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ITEM_ID;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ITEM_TYPE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.KEYWORDS;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.KEYWORD_SECTION;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ORG_NAME;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ORG_TYPE_ID;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.PERFORMANCE_TASK;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.PRIMARY_CLAIM;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.PRIMARY_COMMON_CORE_STANDARD;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.PRIMARY_CONTENT_DOMAIN;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.PRIMARY_ENHANCED_ID;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.PRIMARY_TARGET;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.QUATERNARY_CLAIM;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.QUATERNARY_COMMON_CORE_STANDARD;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.QUATERNARY_CONTENT_DOMAIN;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.QUATERNARY_ENHANCED_ID;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.QUATERNARY_TARGET;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.SCORING_ENGINE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.SECONDARY_CLAIM;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.SECONDARY_COMMON_CORE_STANDARD;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.SECONDARY_CONTENT_DOMAIN;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.SECONDARY_ENHANCED_ID;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.SECONDARY_TARGET;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.SPANISH_CONTENT_LAST_UPDATED_DATE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.SPANISH_PASSAGES_COUNT;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.STIMULUS_ID;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.SUBJECT;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.TERTIARY_CLAIM;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.TERTIARY_COMMON_CORE_STANDARD;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.TERTIARY_CONTENT_DOMAIN;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.TERTIARY_ENHANCED_ID;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.TERTIARY_TARGET;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.TEST_CATEGORY;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.TRANSLATED_GLOSSARY_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.TRANSLATED_GLOSSARY_REQUIRED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.TRANSLATION_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.TRANSLATION_REQUIRED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.TTS_SIGHT_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.TTS_VISUAL_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.TTS_VISUAL_REQUIRED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.UPDATED_DATE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.VALIDATION_RESULT_SEVERITY_COUNT_BENIGN;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.VALIDATION_RESULT_SEVERITY_COUNT_DEGRADED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.VALIDATION_RESULT_SEVERITY_COUNT_SEVERE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.VALIDATION_RESULT_SEVERITY_COUNT_TOLERABLE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.WORKFLOW_STATUS;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.WORKFLOW_STATUS_UPDATE_DATE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.WRITING_PURPOSE;

public class SearchFilterConverterTest {
    private final static List<String> matchFilterProperties = Arrays.asList(GRADE,
            DOK,
            WORKFLOW_STATUS,
            ITEM_TYPE,
            SUBJECT,
            ORG_TYPE_ID,
            ASL_PROVIDED,
            ASL_REQUIRED,
            BRAILLE_PROVIDED,
            BRAILLE_REQUIRED,
            CC_PROVIDED,
            CC_REQUIRED,
            TRANSLATION_PROVIDED,
            TRANSLATION_REQUIRED,
            PRIMARY_CLAIM,
            PRIMARY_TARGET,
            SECONDARY_CLAIM,
            SECONDARY_TARGET,
            QUATERNARY_CLAIM,
            QUATERNARY_TARGET,
            TERTIARY_CLAIM,
            TERTIARY_TARGET,
            PERFORMANCE_TASK,
            WRITING_PURPOSE,
            TEST_CATEGORY,
            SCORING_ENGINE,
            ALLOW_CALCULATOR,
            TTS_VISUAL_REQUIRED,
            CURRENT_UPDATE_NEED_INTERNAL_RESOLUTION,
            CURRENT_UPDATE_NEED_RESOLUTION,
            ILLUSTRATED_GLOSSARY_REQUIRED,
            TRANSLATED_GLOSSARY_REQUIRED);

    private final static List<String> containsFlagFilterProperties = Arrays.asList(ORG_NAME,
            ITEM_AUTHOR,
            CREATED_BY,
            CONTENT_TASK_MODEL,
            PRIMARY_COMMON_CORE_STANDARD,
            SECONDARY_COMMON_CORE_STANDARD,
            TERTIARY_COMMON_CORE_STANDARD,
            QUATERNARY_COMMON_CORE_STANDARD,
            PRIMARY_CONTENT_DOMAIN,
            SECONDARY_CONTENT_DOMAIN,
            TERTIARY_CONTENT_DOMAIN,
            QUATERNARY_CONTENT_DOMAIN,
            PRIMARY_ENHANCED_ID,
            SECONDARY_ENHANCED_ID,
            TERTIARY_ENHANCED_ID,
            QUATERNARY_ENHANCED_ID,
            ASSIGNEES,
            ASSIGNED_BY);

    private final static List<String> dateRangeFilterProperties = Arrays.asList(CREATE_DATE,
            WORKFLOW_STATUS_UPDATE_DATE,
            ENGLISH_CONTENT_LAST_UPDATED_DATE,
            SPANISH_CONTENT_LAST_UPDATED_DATE,
            UPDATED_DATE,
            CURRENT_UPDATE_NEED_CREATED_DATE,
            CURRENT_UPDATE_NEED_INTERNAL_RESOLUTION_DATE,
            CURRENT_UPDATE_NEED_RESOLUTION_DATE);

    private final static List<String> integerRangeFilterProperties = Arrays.asList(CALCULATED_EXPOSURES_COUNT,
            CALCULATED_FORM_COUNT,
            ITEM_DIFFICULTY_QUINTILE,
            ENGLISH_PASSAGES_COUNT,
            SPANISH_PASSAGES_COUNT,
            ASSOCIATED_ITEM_COUNT,
            VALIDATION_RESULT_SEVERITY_COUNT_SEVERE,
            VALIDATION_RESULT_SEVERITY_COUNT_DEGRADED,
            VALIDATION_RESULT_SEVERITY_COUNT_TOLERABLE,
            VALIDATION_RESULT_SEVERITY_COUNT_BENIGN);

    private final static List<String> booleanFlagFilterProperties = Arrays.asList(
            BEING_CREATED,
            CONTENT_CHANGED_AFTER_OPERATIONAL,
            TTS_SIGHT_PROVIDED,
            TTS_VISUAL_PROVIDED,
            ASL_UPLOADED_PRIOR_TO_LAST_CONTENT_UPDATE,
            BRAILLE_UPLOADED_PRIOR_TO_LAST_CONTENT_UPDATE,
            CLOSED_CAPTIONING_UPLOADED_PRIOR_TO_LAST_CONTENT_UPDATE,
            HAS_UNRESOLVED_UPDATE_NEED,
            ENGLISH_GLOSSARY_PROVIDED,
            ILLUSTRATED_GLOSSARY_PROVIDED,
            TRANSLATED_GLOSSARY_PROVIDED
    );

    private final static List<String> idMatchFilterProperties = Arrays.asList(ITEM_ID, STIMULUS_ID);
    private final static List<String> daysBetweenFilterProperties = Collections.singletonList(DAYS_IN_WORKFLOW_STATUS);
    private final static List<String> formMatchFilterProperties = Arrays.asList(FORM_TYPE, ASSESSMENT_TYPE);
    private final static List<String> keywordFilterProperties = Collections.singletonList(KEYWORDS);
    private final static List<String> assignedDateFilterProperties = Collections.singletonList(ASSIGNED_DATES);

    private SearchFilterConverter converter;

    @Before
    public void setUp() {
        converter = new SearchFilterConverter();
    }

    @Test
    public void shouldVerifyAllFiltersConverted() {

        Set<String> allFields = new HashSet<>(matchFilterProperties);
        allFields.addAll(containsFlagFilterProperties);
        allFields.addAll(dateRangeFilterProperties);
        allFields.addAll(integerRangeFilterProperties);
        allFields.addAll(booleanFlagFilterProperties);
        allFields.addAll(idMatchFilterProperties);
        allFields.addAll(daysBetweenFilterProperties);
        allFields.addAll(formMatchFilterProperties);
        allFields.addAll(keywordFilterProperties);
        allFields.addAll(assignedDateFilterProperties);

        //TODO - Keyword section isn't searchable but is a search property. This needs to be reviewed why it is necessary
        allFields.add(KEYWORD_SECTION);

        Set<SearchProperty> searchProperties = new HashSet<>(Arrays.asList(SearchProperty.values()));
        allFields.remove(SearchProperty.PERMISSIONS.getProperty());
        searchProperties.remove(SearchProperty.PERMISSIONS);

        searchProperties.forEach(searchProperty -> assertThat(allFields).contains(searchProperty.getProperty()));
    }

    @Test
    public void shouldConvertMatchFilters() {
        final String filterValue = "test";

        matchFilterProperties
                .stream().map(s -> new MatchFilter(s, false, Collections.singletonList(filterValue)))
                .map(matchFilter -> converter.convert(matchFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(MatchSearchFilter.class);
                    assertThat(((MatchSearchFilter) searchFilter).getFilterValues()).containsExactly("test");
                });
    }

    @Test
    public void shouldConvertIdMatchFilters() {
        final String filterValue = "123";

        idMatchFilterProperties
                .stream().map(s -> new MatchFilter(s, true, Collections.singletonList(filterValue)))
                .map(matchFilter -> converter.convert(matchFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(IdMatchSearchFilter.class);
                    assertThat(((IdMatchSearchFilter) searchFilter).getFilterValues()).containsExactly("123");
                    assertThat(((IdMatchSearchFilter) searchFilter).isIncludeBlanks()).isTrue();
                });
    }

    @Test
    public void shouldConvertKeywordFilter() {
        final String filterValue = "123";

        keywordFilterProperties
                .stream().map(s -> new KeywordFilter(s, true, filterValue))
                .map(keywordFilter -> converter.convert(keywordFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(KeywordSearchFilter.class);
                    assertThat(((KeywordSearchFilter) searchFilter).getValue()).isEqualTo("123");
                    assertThat(((KeywordSearchFilter) searchFilter).isIncludeBlanks()).isFalse();
                });
    }

    @Test
    public void shouldConvertBooleanFlagFilters() {
        booleanFlagFilterProperties
                .stream().map(s -> new BooleanFlagFilter(s, true, Boolean.TRUE))
                .map(booleanFlagFilter -> converter.convert(booleanFlagFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(BooleanFlagSearchFilter.class);
                    assertThat(((BooleanFlagSearchFilter) searchFilter).getFlag()).isEqualTo(Boolean.TRUE);
                });
    }

    @Test
    public void shouldConvertIntegerRangeFilters() {
        integerRangeFilterProperties
                .stream().map(s -> new IntegerRangeFilter(s, true, 1, 2))
                .map(integerRangeFilter -> converter.convert(integerRangeFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(IntegerRangeSearchFilter.class);
                    assertThat(((IntegerRangeSearchFilter) searchFilter).getMin()).isEqualTo(1);
                    assertThat(((IntegerRangeSearchFilter) searchFilter).getMax()).isEqualTo(2);
                });
    }

    @Test
    public void shouldConvertContainsFilters() {
        containsFlagFilterProperties
                .stream().map(s -> new ContainsFilter(s, true, Collections.singletonList("Text")))
                .map(containsFilter -> converter.convert(containsFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(ContainsSearchFilter.class);
                    assertThat(((ContainsSearchFilter) searchFilter).getFilterValues()).containsExactly("Text");
                });
    }

    @Test
    public void shouldConvertDaysBetweenFilters() {
        daysBetweenFilterProperties
                .stream().map(s -> new IntegerRangeFilter(s, false, 1, 2))
                .map(integerRangeFilter -> converter.convert(integerRangeFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(DaysBetweenSearchFilter.class);
                    assertThat(((DaysBetweenSearchFilter) searchFilter).getMin()).isEqualTo(1);
                    assertThat(((DaysBetweenSearchFilter) searchFilter).getMax()).isEqualTo(2);
                    assertThat(((DaysBetweenSearchFilter) searchFilter).isIncludeBlanks()).isFalse();
                });
    }

    @Test
    public void shouldConvertDateRangeFilters() {
        Instant to = Instant.now();
        Instant from = Instant.now().minus(100, ChronoUnit.DAYS);

        dateRangeFilterProperties
                .stream().map(s -> new DateRangeFilter(s, false, to, from))
                .map(dateRangeFilter -> converter.convert(dateRangeFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(DateRangeSearchFilter.class);
                    assertThat(((DateRangeSearchFilter) searchFilter).getTo()).isEqualTo(to);
                    assertThat(((DateRangeSearchFilter) searchFilter).getFrom()).isEqualTo(from);
                });
    }

    @Test
    public void shouldConvertFormMatchFilters() {
        final String filterValue = "test";

        formMatchFilterProperties
                .stream().map(s -> new MatchFilter(s, false, Collections.singletonList(filterValue)))
                .map(matchFilter -> converter.convert(matchFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(FormMatchSearchFilter.class);
                    assertThat(((MatchSearchFilter) searchFilter).getFilterValues()).containsExactly("test");
                });
    }

    @Test
    public void shouldConvertAssociatedCountFilters() {
        IntegerRangeFilter filter = new IntegerRangeFilter(ASSOCIATED_ITEM_COUNT, true, 1, 2);
        SearchFilter searchFilter = converter.convert(filter);

        assertThat(searchFilter).isInstanceOf(AssociatedItemCountSearchFilter.class);

        AssociatedItemCountSearchFilter associatedItemCountSearchFilter = (AssociatedItemCountSearchFilter) searchFilter;

        assertThat(associatedItemCountSearchFilter.getMin()).isEqualTo(1);
        assertThat(associatedItemCountSearchFilter.getMax()).isEqualTo(2);
        assertThat(associatedItemCountSearchFilter.isIncludeBlanks()).isFalse();
    }

    @Test
    public void shouldConvertAssignedDateRangeFilters() {
        Instant to = Instant.now();
        Instant from = Instant.now().minus(100, ChronoUnit.DAYS);

        assignedDateFilterProperties
                .stream().map(s -> new DateRangeFilter(s, false, to, from))
                .map(dateRangeFilter -> converter.convert(dateRangeFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(AssignedDatesDateRangeSearchFilter.class);
                    assertThat(((AssignedDatesDateRangeSearchFilter) searchFilter).getTo()).isEqualTo(to);
                    assertThat(((AssignedDatesDateRangeSearchFilter) searchFilter).getFrom()).isEqualTo(from);
                });
    }
}