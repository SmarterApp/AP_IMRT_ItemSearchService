package org.opentestsystem.ap.imrt.iss.model;

import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.ap.imrt.iss.dto.search.BooleanFlagFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.ContainsFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.DateRangeFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.IntegerRangeFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.MatchFilter;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import static org.assertj.core.api.Assertions.assertThat;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ALLOW_CALCULATOR;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ASL_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ASL_REQUIRED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ASSESSMENT_TYPE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.BEING_CREATED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.BRAILLE_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.BRAILLE_REQUIRED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.CALCULATED_EXPOSURES_COUNT;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.CALCULATED_FORM_COUNT;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.CC_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.CC_REQUIRED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.CONTENT_TASK_MODEL;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.CREATED_BY;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.CREATE_DATE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.DAYS_IN_WORKFLOW_STATUS;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.DOK;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ENGLISH_CONTENT_LAST_UPDATED_DATE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.FORM_TYPE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.GRADE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ITEM_AUTHOR;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ITEM_DIFFICULTY_QUINTILE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ITEM_ID;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ITEM_TYPE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ORG_NAME;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.ORG_TYPE_ID;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.PERFORMANCE_TASK;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.PRIMARY_CLAIM;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.PRIMARY_COMMON_CORE_STANDARD;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.PRIMARY_CONTENT_DOMAIN;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.PRIMARY_TARGET;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.QUATERNARY_CLAIM;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.QUATERNARY_COMMON_CORE_STANDARD;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.QUATERNARY_CONTENT_DOMAIN;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.QUATERNARY_TARGET;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.SCORING_ENGINE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.SECONDARY_CLAIM;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.SECONDARY_COMMON_CORE_STANDARD;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.SECONDARY_CONTENT_DOMAIN;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.SECONDARY_TARGET;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.SPANISH_CONTENT_LAST_UPDATED_DATE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.STIMULUS_ID;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.SUBJECT;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.TERTIARY_CLAIM;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.TERTIARY_COMMON_CORE_STANDARD;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.TERTIARY_CONTENT_DOMAIN;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.TERTIARY_TARGET;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.TEST_CATEGORY;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.TRANSLATION_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.TRANSLATION_REQUIRED;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.UPDATED_DATE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.WORKFLOW_STATUS;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.WORKFLOW_STATUS_UPDATE_DATE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.WRITING_PURPOSE;

public class SearchFilterConverterTest {
    private final static List<String> matchFilterProperties = Arrays.asList(GRADE,
            DOK,
            WORKFLOW_STATUS,
            ITEM_TYPE,
            SUBJECT,
            ORG_TYPE_ID,
            ASL_PROVIDED,
            ASL_REQUIRED,
            BRAILLE_PROVIDED,
            BRAILLE_REQUIRED,
            CC_PROVIDED,
            CC_REQUIRED,
            TRANSLATION_PROVIDED,
            TRANSLATION_REQUIRED,
            PRIMARY_CLAIM,
            PRIMARY_TARGET,
            SECONDARY_CLAIM,
            SECONDARY_TARGET,
            QUATERNARY_CLAIM,
            QUATERNARY_TARGET,
            TERTIARY_CLAIM,
            TERTIARY_TARGET,
            PERFORMANCE_TASK,
            WRITING_PURPOSE,
            TEST_CATEGORY,
            SCORING_ENGINE,
            ALLOW_CALCULATOR);

    private final static List<String> containsFlagFilterProperties = Arrays.asList(ORG_NAME,
            ITEM_AUTHOR,
            CREATED_BY,
            CONTENT_TASK_MODEL,
            PRIMARY_COMMON_CORE_STANDARD,
            SECONDARY_COMMON_CORE_STANDARD,
            TERTIARY_COMMON_CORE_STANDARD,
            QUATERNARY_COMMON_CORE_STANDARD,
            PRIMARY_CONTENT_DOMAIN,
            SECONDARY_CONTENT_DOMAIN,
            TERTIARY_CONTENT_DOMAIN,
            QUATERNARY_CONTENT_DOMAIN);

    private final static List<String> dateRangeFilterProperties = Arrays.asList(CREATE_DATE,
            WORKFLOW_STATUS_UPDATE_DATE,
            ENGLISH_CONTENT_LAST_UPDATED_DATE,
            SPANISH_CONTENT_LAST_UPDATED_DATE,
            UPDATED_DATE);

    private final static List<String> idMatchFilterProperties = Arrays.asList(ITEM_ID, STIMULUS_ID);
    private final static List<String> booleanFlagFilterProperties = Collections.singletonList(BEING_CREATED);
    private final static List<String> daysBetweenFilterProperties = Collections.singletonList(DAYS_IN_WORKFLOW_STATUS);
    private final static List<String> integerRangeFilterProperties = Arrays.asList(CALCULATED_EXPOSURES_COUNT, CALCULATED_FORM_COUNT, ITEM_DIFFICULTY_QUINTILE);
    private final static List<String> formMatchFilterProperties = Arrays.asList(FORM_TYPE, ASSESSMENT_TYPE);

    private SearchFilterConverter converter;

    @Before
    public void setUp() {
        converter = new SearchFilterConverter();
    }

    @Test
    public void shouldConvertMatchFilters() {
        final String filterValue = "test";

        matchFilterProperties
                .stream().map(s -> new MatchFilter(s, false, Collections.singletonList(filterValue)))
                .map(matchFilter -> converter.convert(matchFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(MatchSearchFilter.class);
                    assertThat(((MatchSearchFilter) searchFilter).getFilterValues()).containsExactly("test");
                });
    }

    @Test
    public void shouldConvertIdMatchFilters() {
        final String filterValue = "123";

        idMatchFilterProperties
                .stream().map(s -> new MatchFilter(s, true, Collections.singletonList(filterValue)))
                .map(matchFilter -> converter.convert(matchFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(IdMatchSearchFilter.class);
                    assertThat(((IdMatchSearchFilter) searchFilter).getFilterValues()).containsExactly("123");
                    assertThat(((IdMatchSearchFilter) searchFilter).isIncludeBlanks()).isTrue();
                });
    }

    @Test
    public void shouldConvertBooleanFlagFilters() {
        booleanFlagFilterProperties
                .stream().map(s -> new BooleanFlagFilter(s, true, Boolean.TRUE))
                .map(booleanFlagFilter -> converter.convert(booleanFlagFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(BooleanFlagSearchFilter.class);
                    assertThat(((BooleanFlagSearchFilter) searchFilter).getFlag()).isEqualTo(Boolean.TRUE);
                });
    }

    @Test
    public void shouldConvertIntegerRangeFilters() {
        integerRangeFilterProperties
                .stream().map(s -> new IntegerRangeFilter(s, true, 1, 2))
                .map(integerRangeFilter -> converter.convert(integerRangeFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(IntegerRangeSearchFilter.class);
                    assertThat(((IntegerRangeSearchFilter) searchFilter).getMin()).isEqualTo(1);
                    assertThat(((IntegerRangeSearchFilter) searchFilter).getMax()).isEqualTo(2);
                    assertThat(((IntegerRangeSearchFilter) searchFilter).isIncludeBlanks()).isTrue();
                });
    }

    @Test
    public void shouldConvertContainsFilters() {
        containsFlagFilterProperties
                .stream().map(s -> new ContainsFilter(s, true, Collections.singletonList("Text")))
                .map(containsFilter -> converter.convert(containsFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(ContainsSearchFilter.class);
                    assertThat(((ContainsSearchFilter) searchFilter).getFilterValues()).containsExactly("Text");
                    assertThat(((ContainsSearchFilter) searchFilter).isIncludeBlanks()).isTrue();
                });
    }

    @Test
    public void shouldConvertDaysBetweenFilters() {
        daysBetweenFilterProperties
                .stream().map(s -> new IntegerRangeFilter(s, false, 1, 2))
                .map(integerRangeFilter -> converter.convert(integerRangeFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(DaysBetweenSearchFilter.class);
                    assertThat(((DaysBetweenSearchFilter) searchFilter).getMin()).isEqualTo(1);
                    assertThat(((DaysBetweenSearchFilter) searchFilter).getMax()).isEqualTo(2);
                    assertThat(((DaysBetweenSearchFilter) searchFilter).isIncludeBlanks()).isFalse();
                });
    }

    @Test
    public void shouldConvertDateRangeFilters() {
        Instant to = Instant.now();
        Instant from = Instant.now().minus(100, ChronoUnit.DAYS);

        dateRangeFilterProperties
                .stream().map(s -> new DateRangeFilter(s, false, to, from))
                .map(dateRangeFilter -> converter.convert(dateRangeFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(DateRangeSearchFilter.class);
                    assertThat(((DateRangeSearchFilter) searchFilter).getTo()).isEqualTo(to);
                    assertThat(((DateRangeSearchFilter) searchFilter).getFrom()).isEqualTo(from);
                });
    }

    @Test
    public void shouldConvertFormMatchFilters() {
        final String filterValue = "test";

        formMatchFilterProperties
                .stream().map(s -> new MatchFilter(s, false, Collections.singletonList(filterValue)))
                .map(matchFilter -> converter.convert(matchFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(FormMatchSearchFilter.class);
                    assertThat(((MatchSearchFilter) searchFilter).getFilterValues()).containsExactly("test");
                });
    }
}