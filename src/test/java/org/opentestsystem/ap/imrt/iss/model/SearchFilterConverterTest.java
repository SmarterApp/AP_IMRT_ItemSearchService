package org.opentestsystem.ap.imrt.iss.model;

import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.ap.imrt.iss.dto.search.BooleanFlagFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.ContainsFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.DateRangeFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.IntegerRangeFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.MatchFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import static org.assertj.core.api.Assertions.assertThat;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchFields.*;

public class SearchFilterConverterTest {
    private final static List<String> matchFilterProperties = Arrays.asList(GRADE,
            DOK,
            WORKFLOW_STATUS,
            ITEM_TYPE,
            SUBJECT,
            ORG_TYPE_ID,
            ASL_PROVIDED,
            ASL_REQUIRED,
            BRAILLE_PROVIDED,
            BRAILLE_REQUIRED,
            CC_PROVIDED,
            CC_REQUIRED,
            TRANSLATION_PROVIDED,
            TRANSLATION_REQUIRED,
            PRIMARY_CLAIM,
            PRIMARY_TARGET,
            SECONDARY_CLAIM,
            SECONDARY_TARGET,
            QUATERNARY_CLAIM,
            QUATERNARY_TARGET,
            TERTIARY_CLAIM,
            TERTIARY_TARGET,
            PERFORMANCE_TASK,
            WRITING_PURPOSE,
            TEST_CATEGORY,
            SCORING_ENGINE,
            ALLOW_CALCULATOR,
            TTS_VISUAL_REQUIRED,
            CURRENT_UPDATE_NEED_INTERNAL_RESOLUTION,
            CURRENT_UPDATE_NEED_RESOLUTION,
            ILLUSTRATED_GLOSSARY_REQUIRED,
            TRANSLATED_GLOSSARY_REQUIRED);

    private final static List<String> containsFlagFilterProperties = Arrays.asList(ORG_NAME,
            ITEM_AUTHOR,
            CREATED_BY,
            CONTENT_TASK_MODEL,
            PRIMARY_COMMON_CORE_STANDARD,
            SECONDARY_COMMON_CORE_STANDARD,
            TERTIARY_COMMON_CORE_STANDARD,
            QUATERNARY_COMMON_CORE_STANDARD,
            PRIMARY_CONTENT_DOMAIN,
            SECONDARY_CONTENT_DOMAIN,
            TERTIARY_CONTENT_DOMAIN,
            QUATERNARY_CONTENT_DOMAIN,
            PRIMARY_ENHANCED_ID,
            SECONDARY_ENHANCED_ID,
            TERTIARY_ENHANCED_ID,
            QUATERNARY_ENHANCED_ID);

    private final static List<String> dateRangeFilterProperties = Arrays.asList(CREATE_DATE,
            WORKFLOW_STATUS_UPDATE_DATE,
            ENGLISH_CONTENT_LAST_UPDATED_DATE,
            SPANISH_CONTENT_LAST_UPDATED_DATE,
            UPDATED_DATE,
            CURRENT_UPDATE_NEED_CREATED_DATE,
            CURRENT_UPDATE_NEED_INTERNAL_RESOLUTION_DATE,
            CURRENT_UPDATE_NEED_RESOLUTION_DATE);

    private final static List<String> integerRangeFilterProperties = Arrays.asList(CALCULATED_EXPOSURES_COUNT,
            CALCULATED_FORM_COUNT,
            ITEM_DIFFICULTY_QUINTILE,
            ENGLISH_PASSAGES_COUNT,
            SPANISH_PASSAGES_COUNT,
            ASSOCIATED_ITEM_COUNT,
            VALIDATION_RESULT_SEVERITY_COUNT_SEVERE,
            VALIDATION_RESULT_SEVERITY_COUNT_DEGRADED,
            VALIDATION_RESULT_SEVERITY_COUNT_TOLERABLE,
            VALIDATION_RESULT_SEVERITY_COUNT_BENIGN);

    private final static List<String> booleanFlagFilterProperties = Arrays.asList(
            BEING_CREATED,
            CONTENT_CHANGED_AFTER_OPERATIONAL,
            TTS_SIGHT_PROVIDED,
            TTS_VISUAL_PROVIDED,
            ASL_UPLOADED_PRIOR_TO_LAST_CONTENT_UPDATE,
            BRAILLE_UPLOADED_PRIOR_TO_LAST_CONTENT_UPDATE,
            CLOSED_CAPTIONING_UPLOADED_PRIOR_TO_LAST_CONTENT_UPDATE,
            HAS_UNRESOLVED_UPDATE_NEED,
            ENGLISH_GLOSSARY_PROVIDED,
            ILLUSTRATED_GLOSSARY_PROVIDED,
            TRANSLATED_GLOSSARY_PROVIDED
    );

    private final static List<String> idMatchFilterProperties = Arrays.asList(ITEM_ID, STIMULUS_ID);
    private final static List<String> daysBetweenFilterProperties = Collections.singletonList(DAYS_IN_WORKFLOW_STATUS);
    private final static List<String> formMatchFilterProperties = Arrays.asList(FORM_TYPE, ASSESSMENT_TYPE);
    private final static List<String> keywordFilterProperties = Collections.singletonList(KEYWORDS);

    private SearchFilterConverter converter;

    @Before
    public void setUp() {
        converter = new SearchFilterConverter();

        Set<String> allFields = new HashSet<>(matchFilterProperties);
        allFields.addAll(containsFlagFilterProperties);
        allFields.addAll(dateRangeFilterProperties);
        allFields.addAll(integerRangeFilterProperties);
        allFields.addAll(booleanFlagFilterProperties);
        allFields.addAll(idMatchFilterProperties);
        allFields.addAll(daysBetweenFilterProperties);
        allFields.addAll(formMatchFilterProperties);
        allFields.addAll(keywordFilterProperties);

        //TODO - Keyword section isn't searchable but is a search property. This needs to be reviewed why it is necessary
        allFields.add(KEYWORD_SECTION);

        Arrays.stream(SearchProperty.values()).forEach(searchProperty -> assertThat(allFields).contains(searchProperty.getProperty()));
    }

    @Test
    public void shouldConvertMatchFilters() {
        final String filterValue = "test";

        matchFilterProperties
                .stream().map(s -> new MatchFilter(s, false, Collections.singletonList(filterValue)))
                .map(matchFilter -> converter.convert(matchFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(MatchSearchFilter.class);
                    assertThat(((MatchSearchFilter) searchFilter).getFilterValues()).containsExactly("test");
                });
    }

    @Test
    public void shouldConvertIdMatchFilters() {
        final String filterValue = "123";

        idMatchFilterProperties
                .stream().map(s -> new MatchFilter(s, true, Collections.singletonList(filterValue)))
                .map(matchFilter -> converter.convert(matchFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(IdMatchSearchFilter.class);
                    assertThat(((IdMatchSearchFilter) searchFilter).getFilterValues()).containsExactly("123");
                    assertThat(((IdMatchSearchFilter) searchFilter).isIncludeBlanks()).isTrue();
                });
    }

    @Test
    public void shouldConvertBooleanFlagFilters() {
        booleanFlagFilterProperties
                .stream().map(s -> new BooleanFlagFilter(s, true, Boolean.TRUE))
                .map(booleanFlagFilter -> converter.convert(booleanFlagFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(BooleanFlagSearchFilter.class);
                    assertThat(((BooleanFlagSearchFilter) searchFilter).getFlag()).isEqualTo(Boolean.TRUE);
                });
    }

    @Test
    public void shouldConvertIntegerRangeFilters() {
        integerRangeFilterProperties
                .stream().map(s -> new IntegerRangeFilter(s, true, 1, 2))
                .map(integerRangeFilter -> converter.convert(integerRangeFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(IntegerRangeSearchFilter.class);
                    assertThat(((IntegerRangeSearchFilter) searchFilter).getMin()).isEqualTo(1);
                    assertThat(((IntegerRangeSearchFilter) searchFilter).getMax()).isEqualTo(2);
                });
    }

    @Test
    public void shouldConvertContainsFilters() {
        containsFlagFilterProperties
                .stream().map(s -> new ContainsFilter(s, true, Collections.singletonList("Text")))
                .map(containsFilter -> converter.convert(containsFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(ContainsSearchFilter.class);
                    assertThat(((ContainsSearchFilter) searchFilter).getFilterValues()).containsExactly("Text");
                });
    }

    @Test
    public void shouldConvertDaysBetweenFilters() {
        daysBetweenFilterProperties
                .stream().map(s -> new IntegerRangeFilter(s, false, 1, 2))
                .map(integerRangeFilter -> converter.convert(integerRangeFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(DaysBetweenSearchFilter.class);
                    assertThat(((DaysBetweenSearchFilter) searchFilter).getMin()).isEqualTo(1);
                    assertThat(((DaysBetweenSearchFilter) searchFilter).getMax()).isEqualTo(2);
                    assertThat(((DaysBetweenSearchFilter) searchFilter).isIncludeBlanks()).isFalse();
                });
    }

    @Test
    public void shouldConvertDateRangeFilters() {
        Instant to = Instant.now();
        Instant from = Instant.now().minus(100, ChronoUnit.DAYS);

        dateRangeFilterProperties
                .stream().map(s -> new DateRangeFilter(s, false, to, from))
                .map(dateRangeFilter -> converter.convert(dateRangeFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(DateRangeSearchFilter.class);
                    assertThat(((DateRangeSearchFilter) searchFilter).getTo()).isEqualTo(to);
                    assertThat(((DateRangeSearchFilter) searchFilter).getFrom()).isEqualTo(from);
                });
    }

    @Test
    public void shouldConvertFormMatchFilters() {
        final String filterValue = "test";

        formMatchFilterProperties
                .stream().map(s -> new MatchFilter(s, false, Collections.singletonList(filterValue)))
                .map(matchFilter -> converter.convert(matchFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(FormMatchSearchFilter.class);
                    assertThat(((MatchSearchFilter) searchFilter).getFilterValues()).containsExactly("test");
                });
    }

    @Test
    public void shouldConvertAssociatedCountFilters() {
        IntegerRangeFilter filter = new IntegerRangeFilter(ASSOCIATED_ITEM_COUNT, true, 1, 2);
        SearchFilter searchFilter = converter.convert(filter);

        assertThat(searchFilter).isInstanceOf(AssociatedItemCountSearchFilter.class);

        AssociatedItemCountSearchFilter associatedItemCountSearchFilter = (AssociatedItemCountSearchFilter) searchFilter;

        assertThat(associatedItemCountSearchFilter.getMin()).isEqualTo(1);
        assertThat(associatedItemCountSearchFilter.getMax()).isEqualTo(2);
        assertThat(associatedItemCountSearchFilter.isIncludeBlanks()).isFalse();
    }
}