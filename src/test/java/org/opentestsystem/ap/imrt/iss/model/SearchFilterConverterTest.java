package org.opentestsystem.ap.imrt.iss.model;

import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.ap.imrt.iss.dto.search.BooleanFlagFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.ContainsFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.DateRangeFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.IntegerRangeFilter;
import org.opentestsystem.ap.imrt.iss.dto.search.MatchFilter;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import static org.assertj.core.api.Assertions.assertThat;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.ASL_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.ASL_REQUIRED;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.BEING_CREATED;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.BRAILLE_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.BRAILLE_REQUIRED;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.CALCULATED_EXPOSURES_COUNT;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.CALCULATED_FORM_COUNT;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.CC_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.CC_REQUIRED;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.CONTENT_TASK_MODEL;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.CREATED_BY;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.CREATE_DATE;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.DAYS_IN_WORKFLOW_STATUS;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.DOK;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.GRADE;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.ITEM_AUTHOR;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.ITEM_DIFFICULTY_QUINTILE;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.ITEM_ID;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.ITEM_TYPE;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.ORG_NAME;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.ORG_TYPE_ID;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.PRIMARY_CLAIM;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.PRIMARY_TARGET;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.QUATERNARY_CLAIM;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.QUATERNARY_TARGET;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.SECONDARY_CLAIM;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.SECONDARY_TARGET;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.STIMULUS_ID;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.SUBJECT;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.TERTIARY_CLAIM;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.TERTIARY_TARGET;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.TRANSLATION_PROVIDED;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.TRANSLATION_REQUIRED;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.WORKFLOW_STATUS;
import static org.opentestsystem.ap.imrt.iss.dto.search.Filter.WORKFLOW_STATUS_UPDATE_DATE;

public class SearchFilterConverterTest {
    private final static List<String> matchFilterProperties = Arrays.asList(GRADE,
            DOK,
            WORKFLOW_STATUS,
            ITEM_TYPE,
            SUBJECT,
            ORG_TYPE_ID,
            CONTENT_TASK_MODEL,
            ASL_PROVIDED,
            ASL_REQUIRED,
            BRAILLE_PROVIDED,
            BRAILLE_REQUIRED,
            CC_PROVIDED,
            CC_REQUIRED,
            TRANSLATION_PROVIDED,
            TRANSLATION_REQUIRED,
            PRIMARY_CLAIM,
            PRIMARY_TARGET,
            SECONDARY_CLAIM,
            SECONDARY_TARGET,
            QUATERNARY_CLAIM,
            QUATERNARY_TARGET,
            TERTIARY_CLAIM,
            TERTIARY_TARGET);

    private final static List<String> idMatchFilterProperties = Arrays.asList(ITEM_ID, STIMULUS_ID);
    private final static List<String> booleanFlagFilterProperties = Collections.singletonList(BEING_CREATED);
    private final static List<String> containsFlagFilterProperties = Arrays.asList(ORG_NAME, ITEM_AUTHOR, CREATED_BY);
    private final static List<String> daysBetweenFilterProperties = Collections.singletonList(DAYS_IN_WORKFLOW_STATUS);
    private final static List<String> integerRangeFilterProperties = Arrays.asList(CALCULATED_EXPOSURES_COUNT, CALCULATED_FORM_COUNT, ITEM_DIFFICULTY_QUINTILE);
    private final static List<String> dateRangeFilterProperties = Arrays.asList(CREATE_DATE, WORKFLOW_STATUS_UPDATE_DATE);

    private SearchFilterConverter converter;

    @Before
    public void setUp() {
        converter = new SearchFilterConverter();
    }

    @Test
    public void shouldConvertMatchFilters() {
        final String filterValue = "test";

        matchFilterProperties
                .stream().map(s -> new MatchFilter(s, Collections.singletonList(filterValue)))
                .map(matchFilter -> converter.convert(matchFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(MatchSearchFilter.class);
                    assertThat(((MatchSearchFilter) searchFilter).getFilterValues()).containsExactly("test");
                });
    }

    @Test
    public void shouldConvertIdMatchFilters() {
        final String filterValue = "123";

        idMatchFilterProperties
                .stream().map(s -> new MatchFilter(s, Collections.singletonList(filterValue)))
                .map(matchFilter -> converter.convert(matchFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(IdMatchSearchFilter.class);
                    assertThat(((IdMatchSearchFilter) searchFilter).getFilterValues()).containsExactly("123");
                });
    }

    @Test
    public void shouldConvertBooleanFlagFilters() {
        booleanFlagFilterProperties
                .stream().map(s -> new BooleanFlagFilter(s, Boolean.TRUE))
                .map(booleanFlagFilter -> converter.convert(booleanFlagFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(BooleanFlagSearchFilter.class);
                    assertThat(((BooleanFlagSearchFilter) searchFilter).getFlag()).isEqualTo(Boolean.TRUE);
                });
    }

    @Test
    public void shouldConvertIntegerRangeFilters() {
        integerRangeFilterProperties
                .stream().map(s -> new IntegerRangeFilter(s, 1, 2))
                .map(integerRangeFilter -> converter.convert(integerRangeFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(IntegerRangeSearchFilter.class);
                    assertThat(((IntegerRangeSearchFilter) searchFilter).getMin()).isEqualTo(1);
                    assertThat(((IntegerRangeSearchFilter) searchFilter).getMax()).isEqualTo(2);
                });
    }

    @Test
    public void shouldConvertContainsFilters() {
        containsFlagFilterProperties
                .stream().map(s -> new ContainsFilter(s, Collections.singletonList("Text")))
                .map(containsFilter -> converter.convert(containsFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(ContainsSearchFilter.class);
                    assertThat(((ContainsSearchFilter) searchFilter).getFilterValues()).containsExactly("Text");
                });
    }

    @Test
    public void shouldConvertDaysBetweenFilters() {
        daysBetweenFilterProperties
                .stream().map(s -> new IntegerRangeFilter(s, 1, 2))
                .map(integerRangeFilter -> converter.convert(integerRangeFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(DaysBetweenSearchFilter.class);
                    assertThat(((DaysBetweenSearchFilter) searchFilter).getMin()).isEqualTo(1);
                    assertThat(((DaysBetweenSearchFilter) searchFilter).getMax()).isEqualTo(2);
                });
    }

    @Test
    public void shouldConvertDateRangeFilters() {
        Instant to = Instant.now();
        Instant from = Instant.now().minus(100, ChronoUnit.DAYS);

        dateRangeFilterProperties
                .stream().map(s -> new DateRangeFilter(s, to, from))
                .map(dateRangeFilter -> converter.convert(dateRangeFilter))
                .collect(Collectors.toList())
                .forEach(searchFilter -> {
                    assertThat(searchFilter).isInstanceOf(DateRangeSearchFilter.class);
                    assertThat(((DateRangeSearchFilter) searchFilter).getTo()).isEqualTo(to);
                    assertThat(((DateRangeSearchFilter) searchFilter).getFrom()).isEqualTo(from);
                });
    }
}