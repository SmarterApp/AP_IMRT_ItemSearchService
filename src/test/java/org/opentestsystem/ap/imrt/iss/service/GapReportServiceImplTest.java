package org.opentestsystem.ap.imrt.iss.service;

import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty;
import org.opentestsystem.ap.imrt.iss.model.IdMatchSearchFilter;
import org.opentestsystem.ap.imrt.iss.model.MatchSearchFilter;
import org.opentestsystem.ap.imrt.iss.model.SearchFilter;
import org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReport;
import org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReportBuilder;
import org.opentestsystem.ap.imrt.iss.repository.GapReportRepository;

import java.io.File;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.isA;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.INTENDED_GRADE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.ITEM_ID;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.ITEM_TYPE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.SUBJECT;

@RunWith(MockitoJUnitRunner.class)
public class GapReportServiceImplTest {
    @Mock
    private GapReportRepository mockGapReportRepository;

    @Mock
    private GapReportBuilder mockGapReportBuilder;

    private GapReportService gapReportService;

    @Before
    public void setup() {
        gapReportService = new GapReportServiceImpl(mockGapReportRepository, mockGapReportBuilder);
    }

    @Test
    public void shouldGetGapReport() {
        final Map<String, Object> gapReportRecord = new HashMap<>();
        gapReportRecord.put(SUBJECT.getProperty().toLowerCase(), "ELA");
        gapReportRecord.put(INTENDED_GRADE.getProperty().toLowerCase(), "3");
        gapReportRecord.put(ITEM_TYPE.getProperty().toLowerCase(), "EQ");

        final List<SearchFilter> searchFilters =
                Collections.singletonList(new MatchSearchFilter(SUBJECT, Collections.singletonList("ELA")));
        final List<SearchProperty> groups = Arrays.asList(SUBJECT, INTENDED_GRADE, ITEM_TYPE);

        when(mockGapReportRepository.getGapReport(searchFilters, groups))
                .thenReturn(Collections.singletonList(gapReportRecord));
        when(mockGapReportBuilder.convertToReport(isA(GapReport.class)))
                .thenReturn(new XSSFWorkbook());

        final Optional<File> result = gapReportService.getGapReport(searchFilters, groups);

        verify(mockGapReportRepository).getGapReport(searchFilters, groups);

        assertThat(result).isPresent();

        final File resultFile = result.get();
        assertThat(resultFile.getName()).startsWith("gap-report-");
    }

    @Test
    public void shouldReturnOptionalEmptyWhenSuppliedWithInvalidSearchFilters() {
        final IdMatchSearchFilter emptyIdMatchFilter = new IdMatchSearchFilter(SearchProperty.ITEM_ID,
                Collections.singletonList("foo"));

        final Optional<File> result = gapReportService.getGapReport(Collections.singletonList(emptyIdMatchFilter),
                Collections.singletonList(SUBJECT));

        assertThat(result).isNotPresent();
        verifyZeroInteractions(mockGapReportRepository);
        verifyZeroInteractions(mockGapReportBuilder);
    }

    @Test(expected = IllegalArgumentException.class)
    public void shouldThrowWhenGivenInvalidGroups() {
        final List<SearchFilter> searchFilters =
                Collections.singletonList(new MatchSearchFilter(SUBJECT, Collections.singletonList("ELA")));
        final List<SearchProperty> groups = Arrays.asList(SUBJECT, INTENDED_GRADE, ITEM_TYPE, ITEM_ID);

        gapReportService.getGapReport(searchFilters, groups);
    }
}
