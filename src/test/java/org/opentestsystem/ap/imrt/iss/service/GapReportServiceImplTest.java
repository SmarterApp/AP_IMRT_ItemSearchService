package org.opentestsystem.ap.imrt.iss.service;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty;
import org.opentestsystem.ap.imrt.iss.model.IdMatchSearchFilter;
import org.opentestsystem.ap.imrt.iss.model.MatchSearchFilter;
import org.opentestsystem.ap.imrt.iss.model.SearchFilter;
import org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReport;
import org.opentestsystem.ap.imrt.iss.model.reports.gap.GapReportBuilder;
import org.opentestsystem.ap.imrt.iss.repository.GapReportRepository;

import java.io.File;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.within;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.INTENDED_GRADE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.ITEM_TYPE;
import static org.opentestsystem.ap.imrt.iss.dto.search.SearchProperty.SUBJECT;

@RunWith(MockitoJUnitRunner.class)
public class GapReportServiceImplTest {
    @Mock
    private GapReportRepository mockGapReportRepository;

    @Mock
    private GapReportBuilder mockGapReportBuilder;

    private GapReportService gapReportService;

    @Before
    public void setup() {
        gapReportService = new GapReportServiceImpl(mockGapReportRepository, mockGapReportBuilder);
    }

    @Test
    public void shouldGetGapReport() {
        final Map<String, Object> gapReportRecord = new HashMap<>();
        gapReportRecord.put(SUBJECT.getColumnName(), "ELA");
        gapReportRecord.put(INTENDED_GRADE.getColumnName(), "3");
        gapReportRecord.put(ITEM_TYPE.getColumnName(), "EQ");

        final List<SearchFilter> searchFilters =
                Collections.singletonList(new MatchSearchFilter(SUBJECT, Collections.singletonList("ELA")));
        final List<SearchProperty> groupFilters = Arrays.asList(SUBJECT, INTENDED_GRADE, ITEM_TYPE);

        when(mockGapReportRepository.getGapReport(searchFilters, groupFilters))
                .thenReturn(Collections.singletonList(gapReportRecord));

        final Optional<File> result = gapReportService.getGapReport(searchFilters, groupFilters);

        verify(mockGapReportRepository).getGapReport(searchFilters, groupFilters);

        assertThat(result).isPresent();

        final File gapReport = result.get();
//        assertThat(gapReport.getFilters()).containsExactly(searchFilters.toArray(new SearchFilter[0]));
//        assertThat(gapReport.getGroupFilters()).containsExactly(groupFilters.toArray(new SearchProperty[0]));
//        assertThat(gapReport.getGapReportRecords()).containsExactly(gapReportRecord);
//        assertThat(gapReport.getCreatedDate()).isCloseTo(Instant.now(), within(1, ChronoUnit.SECONDS));
    }

    @Test
    public void shouldReturnOptionalEmptyWhenSuppliedWithInvalidSearchFilters() {
        final IdMatchSearchFilter emptyIdMatchFilter = new IdMatchSearchFilter(SearchProperty.ITEM_ID,
                Collections.singletonList("foo"));

        final Optional<File> result = gapReportService.getGapReport(Collections.singletonList(emptyIdMatchFilter),
                Collections.singletonList(SUBJECT));

        assertThat(result).isNotPresent();
        verifyZeroInteractions(mockGapReportRepository);
    }
}
