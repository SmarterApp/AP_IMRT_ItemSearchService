package org.opentestsystem.ap.imrt.iss.service;

import org.assertj.core.util.Maps;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.ap.imrt.iss.config.ResourceServerProperties;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.oauth2.common.exceptions.InvalidTokenException;
import org.springframework.security.oauth2.provider.OAuth2Authentication;
import org.springframework.security.oauth2.provider.OAuth2Request;
import org.springframework.security.oauth2.provider.token.AccessTokenConverter;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestOperations;

import java.util.HashMap;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class OpenAmTokenServicesTest {
    private static final String testUrl = "http://testUrl";
    private static final String testToken = "token 1 2 3";
    private HttpHeaders expectedHeaders;

    @Rule
    public ExpectedException thrown = ExpectedException.none();

    @Mock
    private RestOperations mockRestTemplate;

    @Mock
    private AccessTokenConverter mockTokenConverter;

    // Class under test
    private OpenAmTokenServices openAmTokenServices;

    @Before
    public void setup() {
        ResourceServerProperties properties = new ResourceServerProperties();
        properties.setCheckTokenEndpointUrl(testUrl);
        openAmTokenServices = new OpenAmTokenServices(properties, mockTokenConverter, mockRestTemplate);
        expectedHeaders = new HttpHeaders();
        expectedHeaders.set("Authorization", "Bearer " + testToken);

    }

    @Test
    public void shouldThrowRestClientException() {
        when(mockRestTemplate.exchange(testUrl, HttpMethod.GET, new HttpEntity<MultiValueMap<String, String>>(null, expectedHeaders), Map.class))
                .thenThrow(new RestClientException("test"));
        thrown.expect(RestClientException.class);
        openAmTokenServices.loadAuthentication(testToken);
    }

    @Test
    public void shouldThrowInvalidTokenException() {
        Map<String, Object> resultMap = Maps.newHashMap("error", "invalid token");
        when(mockRestTemplate.exchange(testUrl, HttpMethod.GET, new HttpEntity<MultiValueMap<String, String>>(null, expectedHeaders), Map.class))
                .thenReturn(new ResponseEntity<>(resultMap, HttpStatus.OK));
        thrown.expect(InvalidTokenException.class);
        thrown.expectMessage(testToken);
        openAmTokenServices.loadAuthentication(testToken);
    }

    @Test
    public void shouldValidateToken() {
        Map<String, Object> resultMap = Maps.newHashMap("good", "stuff");
        when(mockRestTemplate.exchange(testUrl, HttpMethod.GET, new HttpEntity<MultiValueMap<String, String>>(null, expectedHeaders), Map.class))
                .thenReturn(new ResponseEntity<>(resultMap, HttpStatus.OK));
        OAuth2Request request = new OAuth2Request(new HashMap<>(), null, null, true,
                null, null, null, null, null);
        OAuth2Authentication resultAuth = new OAuth2Authentication(request, null);
        when(mockTokenConverter.extractAuthentication(resultMap)).thenReturn(resultAuth);

        assertThat(openAmTokenServices.loadAuthentication(testToken)).isEqualTo(resultAuth);
        verify(mockRestTemplate).exchange(testUrl, HttpMethod.GET, new HttpEntity<MultiValueMap<String, String>>(null, expectedHeaders), Map.class);
        verify(mockTokenConverter).extractAuthentication(resultMap);

    }
}
